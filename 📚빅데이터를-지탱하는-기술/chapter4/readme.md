<img width="493" alt="image" src="https://github.com/led156/TIL/assets/67251510/925bdc8e-95ff-458a-a40d-70377f6f9b65">


# 4.1. 벌크 형과 스트리밍 형의 데이터 수집
## 객체 스토리지와 데이터 수집
- 빅데이터는 대부분 확장성이 높은 '분산 스토리지(distributed storage)'에 저장됨.
  <img width="593" alt="image" src="https://github.com/led156/TIL/assets/67251510/d7c9feb9-acb9-4b4a-9c62-1202cfa8d295">

  + 분산 형의 데이터베이스가 이용되는 경우도 있지만, 기본은 대량으로 파일을 저장하기 위해 '객체 스토리지(object storage)'임.
  + Hadoop의 'HDFS', 클라우드 서비스로는 'Amazon S3'
  + 객체 스토리지에서의 파일 읽고 쓰기는 네트워크를 거쳐서 실행함.
    * 내부 처리에 다수의 물리적인 서버와 하드 디스크가 있음.
    * 데이터는 여러 디스크에 복사되기 때문에 일부 하드웨어가 고장나더라도 데이터가 손실되지 않는다.
    * 데이터의 읽고 쓰기를 다수 하드웨어에 분산함으로써 데이터의 양이 늘어나도 성능이 떨어지는 일이 없도록 고안되어 있다.
  + 객체 스토리지의 구조는 데이터양이 많을 때 우수하지만, 소량의 데이터에는 비효율적임에 주의.
    * 예시) 100바이트의 작은 파일을 자주 읽고 쓰는 것은 적합X. 데이터양에 비해 통신 오버헤드가 크기 때문.

### 데이터 수집
- 데이터 수집(data ingesion) : 수집한 데이터를 가공하여 집계 효율이 좋은 분산 스토리지를 만드는 일련의 프로세스. (데이터 수집부터~ 구조화 데이터의 작성, 분산 스토리지에 대한 장기적 저장)
- 빅데이터로 자주 다루는 것은 시간과 함께 생성되는 데이터임 (시계열 데이터)
- 이를 수시로 객체 스토리지에 기록하면 대량의 작은 파일이 생성됨 → 시간이 지남에 따라 성능 저하의 요인이 됨. ⇒ 작은 데이터를 적당히 모아 하나의 큰 파일로 만들어 효율을 높인다.
- 반대로, 지나치게 파일이 커도 문제가 있음.
  + 파일 크기가 증가하면 네트워크 전송에 시간이 걸려 예상치 못한 오류 발생률이 높아짐.
- 단순히 수집보다 나중에 처리하기 쉽도록 준비해 둘 필요가 있음.
  + 객체 스토리지에서 효율적으로 처리할 수 있는 파일 크기는 1MB~1GB 사이이다.

## 벌크 형의 데이터 전송
- 전통적인 데이터 웨어하우스에서 사용.
  + 데이터베이스나 파일 서버/웹 서비스 등에서 각각의 방식(SQL, API 등)으로 정리해 데이터를 추출.
  + 과거 축적된 대량의 데이터 / 기존 데이터를 추출하고 싶을 경우에도 사용.
- 데이터가 처음부터 분산 스토리지에 저장되어 있지 않다면, 데이터 전송을 위한 'ETL 서버'를 설치함.
  <img width="482" alt="image" src="https://github.com/led156/TIL/assets/67251510/427f5d11-d000-4283-bdb6-d10fd573f64f">

  + ELT 서버 : 구조화된 데이터 처리에 적합하고, 데이터 웨어하우스를 위한 ETL 도구 & 오픈 소스의 벌크 전송 도구 또는 손수 작성한 스크립트 등을 사용 가능.

### 파일 사이즈의 적정화는 비교적 간단하다
- ETL 프로세스는 1시간~하루마다 간격으로 정기적 실행을 함 → 파일 사이즈를 자동으로 적정화.
- 그렇게 사용하고 있지 않다면 전송 방법을 검토
  + 예시) 100개의 파일을 전송할 때 100번 전송하는 것이 아닌, 모아서 전송. = 한 번의 전송에 모든 파일을 포함
  + 데이터 양이 많을 때는 단위를 조절해 작은 태스크로 분해. (워크플로 관리 도구 사용)
 
### 데이터 전송의 워크플로
- 데이터 전송의 신뢰성이 중요한 경우에는 벌크형 도구를 주로 사용.
  + 스트리밍형의 경우 데이터 전송 재실행이 쉽지 않음.
  + 벌크형 전송의 장점 → 문제가 발생했을 때 전송을 재실행할 수 있음.
  + ⇒ 과거의 데이터를 빠짐없이 가져오거나, 실패한 작업을 재실행할 것을 고려하면 .. 벌크형 전송으로!
- 벌크 형 데이터 전송은 워크플로 관리 도구와의 궁합이 뛰어남.
  + 정기적인 스케줄 실행/오류 통지등을 워크플로 관리 도구에 맡김.
  + 매일 매일 마스터 데이터 스냅샷 & 신뢰성이 중시되는 과금 데이터 전송 등은 다른 배치 처리와 함께 워크플로의 일부에 포함시키는 것이 좋음 ❓

## 스트리밍 형의 데이터 전송
<img width="607" alt="image" src="https://github.com/led156/TIL/assets/67251510/fbe60b40-af96-4dfd-b59d-c893bc5b1f08">

- 대다수 데이터는 통신 장비 및 소프트웨어에 의해 생성, 그리고 네트워크를 거쳐 전송됨. (웹 브라우저, 모바일 앱, 각종 디바이스 등)
  + 지금 바로 생성되어 어디에도 저장되지 않은 데이터를 바로 전송 : 스트리밍 형 데이터 전송이 필요.
- 이러한 데이터 전송의 공통점
  + 메시지 배송(message delivery) : 다수의 클라이언트에서, 계속해서 작은 데이터가 전송됨.
  + 전송되는 데이터양에 비해 통신을 위한 오버헤드가 큼. → 처리하는 서버의 성능이 높아야 함.
- 보내온 메시지를 저장하는 방법
  1. 작은 데이터 쓰기에 적합한 NoSQL 데이터베이스 : Hive와 같은 쿼리 엔진으로 NoSQL 데이터베이스에 연결해 데이터를 읽는다.
  2. 메시지 큐(message queue), 메시지 브로커(message broker) 등의 중계 시스템에 전송 : 등록된 데이터를 일정한 간격으로 꺼내고 모아서 함께 분산 스토리지에 저장한다.
 
### 웹 브라우저에서의 메시지 배송 : Fluentd, Logstash, 웹 이벤트 트래킹
<img width="400" alt="image" src="https://github.com/led156/TIL/assets/67251510/5ac4b66a-5035-4e7e-b860-99a95451966f">

- ❶ 웹 서버 안에서 메시지를 만들어 배송
  + 자체 개발한 웹 애플리케이션 등에서 주로 사용
  + 전송 효율을 높이기 위해 서버상에서 데이터를 축적해 놓고 나중에 모아서 보내는 경우가 많음.
  + Fluentd, Logstash 같은 서버 상주형 로그 수집 소프트웨어가 주로 사용됨.
    * Fluentd에 의한 메시지 배송
    * 
      <img width="388" alt="image" src="https://github.com/led156/TIL/assets/67251510/11930ab6-1a33-4cff-93e4-7c6f8ee990e5">

      - 분산 스토리지에 데이터를 중계하는 메시지 브로커의 역할로 사용.
        + 원래 메시지 브로커로 설계된 것이 아니기 때문에, 한계 존재
          1. 여러 대로 데이터를 복제할 수 없음 : 노드가 고장 나서 버퍼가 사라진다면 보내지 못한 데이터가 없어짐 (디스크 상 버퍼가 사라지지 않는 한 재전송할 수는 있다.)
          2. 메시지를 일방적으로 발송하는 것밖에 못함 : 외부에서 요청해서 메시지를 꺼낼 수 없음.
          3. 배송에 성공한 메시지는 곧 사라져 버리기 때문에 나중에 다시 송신할 수 없음.
      - 내부에 효율적인 버퍼링 메커니즘을 갖고 있음 : 일정 시간 간격/특정 사이즈에 외부로 데이터를 모아 내보낼 수 있음.
      - 필요에 따라 부분적으로 데이터를 바꾸어 쓰거나 복수의 스토리지에 복사할 수 있음.
        
- ❷ 자바스크립트를 사용하여 웹 브라우저에서 직접 메시지를 보냄 : 웹 이벤트 추적(web event tracking)
  + 사용자 측면에서 HTML 페이지에 태그를 삽입만 하면 되어 각종 액세스 분석 서비스 / 데이터 분석 서비스 등에서 사용됨.
  + 수집된 데이터는 그대로 다른 서버로 전송되거나 API 경유로 함께 취득해, 분산 스토리지에 저장함.

### 모바일 앱으로부터의 메시지 배송 : MBaas, SDK
<img width="391" alt="image" src="https://github.com/led156/TIL/assets/67251510/e8863313-2c24-4e27-b8da-b32790fd699b">

- HTTP 프로토콜을 사용 : 통신 방법만 봤을 때 웹 브라우저와 메시지 배송 방식이 동일.
- ❶ MBaaS 경유의 메시지 배송
  + 모바일 앱에서 서버를 직접 마련하는 것이 아닌 MBaas(Mobile Backend as a Service)라는 백엔드의 각종 서비스를 이용할 수 있음.
  + 백엔드 데이터 저장소에 저장한 데이터를 벌크 형 도구를 사용해 꺼냄
- ❷ SDK에 의한 메시지 배송
  + 모바일 앱에 특화된 액세스 해석 서비스를 통해 이벤트 데이터를 수집
  + 서비스에서 제공되는 모바일 용의 편리한 개발 키트(SDK) 사용
  + 오프라인에서 모바일 앱이 사용될 수도 있으므로 발생한 이벤트는 일단 SDK 내부에 축적되고 온라인 상태가 되었을 때 모아서 보내도록 되어 있음.
- 모바일 회선은 통신이 불안정하고 통신 오류에 따른 메시지 재전송이 여러 번 발생함.
  + 따라서 데이터가 중복될 가능성이 높음. → 특정한 중복 제거의 구조도 필요.

### 디바이스로부터의 메시지 배송 : MQTT
- MQTT(MQ Telemetry Transport)
  <img width="374" alt="image" src="https://github.com/led156/TIL/assets/67251510/7d5aed87-de85-4ac2-a665-054b75589a8f">

  + TCP/IP를 사용하여 데이터를 전송하는 프로토콜의 하나
  + Pub/Sub 형 메시지 배송(Pub/Sub message delievery) 구조 ;채팅 시스템/메시징 앱/푸시 알림등에서 주로 사용
      * Pub : 전달(publish)
      * Sub : 구독(subscription)
- MQTT에서 먼저 관리자에 의해 '토픽(topic)'이 만들어짐.
  + 토픽 : 메시지를 송수신하기 위한 대화방과 같은 것
    * 토픽을 구독하면 메시지가 도착하게 되고, 그 토픽을 전달하면 구독 중인 모든 클라이언트에 보내짐
  + MQTT 브로커(MQTT broker) : 메시지의 교환을 중계하는 서버
  + MQTT 구독자(MQTT subscriber) : 메시지를 수신하는 시스템
- 네트워크에서 분리된 경우에도 나중에 재전송하는 구조가 프로토콜 수준에서 고려됨. (HTTP에선 이런 구조를 스스로 생각해야 하지만, MQTT에선 이미 있고 이를 사용 가능하다)
1. 토픽을 작성하고 이를 구독한다.
2. 각 디바이스가 토픽에 메시지를 전달하는 프로그램을 작성한다.
3. MQTT가 정해진 규칙에 따라 메시지 배송을 한다.

### 메시지 배송의 공통화
- 메시지 배송 방식은 어디에서 데이터를 수집하느냐에 달라짐.
- 클라이언트(client) : 메시지가 처음 생성되는 기기
- 프런트 엔드(frontend) : 생성된 메시지를 먼저 받는 서버
  + 클라이언트와의 통신 프로토콜을 구현해야 함.
  + 공격으로부터 데이터를 보호하기 위해 암호화/사용자 인증을 구현
  + 성능 문제를 해결하기 위해 높은 확장성 필요
+ 메시지 브로커 : 프런트 엔드에서 받은 메시지를 전달 받음.
  + 분산 스토리지에 데이터를 저장



# 4.2. [성능×신뢰성] 메시지 배송의 트레이드 오프
- 클라이언트의 수가 많아지면 스트리밍 형의 메시지 배송의 '성능'과 '신뢰성'을 둘 다 만족하기 어려움.

## 메시지 브로커
- 쓰기의 빈도가 증가해 디스크 성능이 한계에 도달하면, 데이터 저장에 문제가 생김
  + 외부에서 들어오는 메시지 양을 제어할 수 없기 때문에 급격한 양 증가에 대응하기 쉽지 않음.
- 쓰기 성능 한계에 의해 오류가 생기면, 대부분 클라이언트는 메시지를 재성능하려고 함 → 부하만 높아질 뿐임.
- 대량의 메시지를 안정적으로 받기 위해 쓰기 성능이 매우 높고 필요에 따라 쓰기를 높일 수 있는 스토리지가 필요.
  + 분산 스토리지가 이런 성격을 무조건 갖고 있지 않기 때문에 메시지 브로커 도입.
- 메시지 브로커(message broker) : 데이터를 일시적으로 축적하는 중산층 (Apache Kafka, Amazon Kinesis)
  <img width="592" alt="image" src="https://github.com/led156/TIL/assets/67251510/cacc7a15-024c-48bc-85ff-3878479924d6">

### 푸쉬 형과 풀 형
- 푸시 형 : 송신 측의 제어로 데이터를 보내는 방식
- 풀 형 : 수신 측의 주도로 데이터를 가져오는 것
- 이때 메시지 브로커는 데이터의 쓰기 속도를 조정하기 위한 완충 부분, 푸쉬 형에서 풀 형으로 메시지 배송 타이밍을 변환함.
  + 생산자 : 메시지 브로커에 데이터를 넣는(push) 것
  + 소비자 : 메시지 브로커에서 데이터를 꺼내오는(pull) 것
- 메시지 브로커
  + 높은 빈도를 가진 데이터 쓰기에 최적화되어 있음
  + 여러 대 노드에 부하 분산할 수 있음 (뛰어난 확장성)
  + 푸쉬 형 메시지 배송은 메시지 브로커에 집중시키고, 일정한 빈도(=메시지의 양을 조절하는 것)로 꺼낸 데이터를 분산 스토리지에 기록하여 성능 문제 해결
 
### 메시지 라우팅
<img width="591" alt="image" src="https://github.com/led156/TIL/assets/67251510/72987985-0ff3-4939-adad-54c42d4baef1">

- 예시)
  + 100만 대의 디바이스에서 1분마다 100바이트의 메시지를 수신
  + 시스템 전체가 받는 메시지는 초당 1.7만 메시지 (=1.66MB)
  + 초당 1.7만 번 쓰기를 견디는 데이터베이스 준비는 쉽지 않음.
- 스트림 처리(stream processing) : 짧은 간격으로 차례대로 데이터를 꺼내서 처리하는 것
  + 프런트 엔드에서 메시지 브로커에 데이터를 푸쉬하고, '소비자'에서 모아서 가져옴 (1초마다 가져오면 한 번에 1.66MB 데이터양을 가져옴)
- 메시지 브로커에 넣은 데이터는 복수의 다른 소비자에서 읽을 수 있음.
  + 메시지가 복사되어 데이터를 여러 경로로 분기시킬 수 있음 : 메시지 라우팅(message routing)
  + 예시) 메시지 일부를 실시간 장애 감지에 사용하면서 같은 메시지를 장기적인 데이터 분석을 위한 분산 스토리지에 저장하는 것도 가능.
 
## 메시지 배송을 확실하게 실시하는 것은 어렵다
- 모바일 회선과 같이 신뢰성이 낮은 네트워크에서 메시지 중복과 누럭을 어떻게 처리할 지.
  + 중앙에 코디네이터가 존재할 경우 : at most once / at least once
  + 존재하지 않을 경우(중복이 발생)
- 자바스크립트에 의한 데이터 수집은 그다지 신뢰할 수 없음 : 웹페이지를 닫는 것만으로도 쉽게 작동이 중지되기 때문.

|소프트웨어|신뢰성|
|---|---|
|Apache Flume|'at least once' 보장|
|Apache Kafka|'at least once' 보장|
|Logstash|'at least once' 보장|
|Fluentd|옵션으로 'at least once' 보장|

### 1. at most once
- at most once : 메시지는 한 번만 전송된다. 그러나 도중에 전송에 실패해서 사라질 가능성이 있다. (결손)
  + 재전송을 지원하는 시스템에서 이를 보장하기 어렵다.
- 예시) 결손을 피하고자 재전송(retransmission)이 이뤄지는 경우
  + 두 노드 간에 TCP/IP로 메시지를 보낸다.
  + 수신 완료를 나타내는 'ack'가 반환되기 직전에 네트워크 통신이 중단 시.
  + 송신 측에서는 타임아웃을 감지하고 재전송 시작 → 접속이 재개되면 메시지가 재전송됨.
  + 수신 측에서는 메시지를 다받았기 때문에 타임아웃에 의한 통신 종료를 기다리지 않고 데이터 처리를 그냥 진행. ⇒ 중복 발생

### 2. exactly once
- exactly once : 메시지는 손실되거나 중복 없이 한 번만 전달된다
- 코디네이터(coordinator) : 네트워크상에서 분단된 두 개의 노드가 있는 경우, 양쪽의 통신 내용을 보장하기 위해 존재하는 중계기
  + 메시지 송신, 수식 측 정보를 코디네이터에게 전달함으로써 문제 발생시에 코디네이터의 지시에 따라 해결함.
1. 문제점 : 분산 시스템에서 코디네이터가 항상 존재한다고 가정할 수 없다.
   - 코디네이터 통신이 끊기거나, 정지될 경우 이러한 부재의 경우에 어떻게 할 것인지 합의(consensus)가 필요한데, 분산 시스템 설계에서 이는 어려운 문제 중 하나임. (단시간 장애가 발생한다로 주로 결정됨)
2. 문제점 : 코디네이터 판단에만 따르고 있으면 시간이 너무 소요된다.


### 3. at least once
- at least once : 메시지는 확실히 전달된다. 단 같은 것이 여러 번 전달될 가능성이 있다. (중복)
  + 중복 제거(deduplication : 재전송된 메시지를 지움)을 통해 중복이 없는 것처럼 보이게 함.
- 예시) TCP/IP에 의한 네트워크 통신으로 비유
  + IP 통신 : 데이터의 누락, 중복이 일어날 수 있는 신뢰성이 없는 메시지 배송 방식
  + TCP 통신 : 메시지 수신 확인을 위한 'ack' 플래그 도입 (at least once)
    * 메시지 재전송에 의한 중복이 발생하지만, TCP 패킷을 식별하는 시퀀스 번호가 있기 때문에 이를 이용해 중복 제거가 이뤄짐. (메시지 배송 시스템에서 중복 제거는 이용자에게 맡김...)


## 중복 제거는 높은 비용의 오퍼레이션



# 4.3.


# 4.4.



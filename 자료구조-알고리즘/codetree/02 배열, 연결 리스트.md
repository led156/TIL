# 배열
## 정적 배열
- 배열의 선언과 동시에 크기를 정해줘야 하며, 한번 선언된 이후부터는 크기를 바꿀 수 없음.
### 시간복잡도
- 삽입
  + 앞 또는 가운데에 새로운 값을 삽입하는 경우라면, 다른 값들이 한칸씩 이동해야 하므로 : O(N)
  + 항상 배열의 맨 뒤에 새로운 값을 삽입하는 경우만 발생한다면, 값 이동이 없으므로 : O(1)
- 삭제
  + 앞 또는 가운데에 값을 제거하는 경우라면, 다른 값들이 한칸씩 이동해야 하므로 : O(N)
  + 항상 배열의 맨 뒤에 값을 제거하는 경우만 발생한다면, 값 이동이 없으므로 : O(1)
- 탐색
  + 처음부터 끝까지 모든 값을 훑으면 : O(N)
- k번째 원소 값 구하기
  + 배열은 index 기반으로 이루어져 있기 때문에, 바로 원소를 구할 수 있음 : O(1)

## 동적 배열
- 동적으로, 배열의 길이를 줄어들고 늘어나도록 바꿀 수 있음.
- java : `ArrayList`, c++ : `vector`, python : `[]`

### 시간복잡도
- 삽입
  + 앞 또는 가운데에 새로운 값을 삽입하는 경우라면, 다른 값들이 한칸씩 이동해야 하므로 : O(N)
  + 항상 배열의 맨 뒤에 새로운 값을 삽입하는 경우만 발생한다면, 값 이동이 없으므로 : O(1)
- 삭제
  + 앞 또는 가운데에 값을 제거하는 경우라면, 다른 값들이 한칸씩 이동해야 하므로 : O(N)
  + 항상 배열의 맨 뒤에 값을 제거하는 경우만 발생한다면, 값 이동이 없으므로 : O(1)
- 탐색
  + 처음부터 끝까지 모든 값을 훑으면 : O(N)
- k번째 원소 값 구하기
  + 배열은 index 기반으로 이루어져 있기 때문에, 바로 원소를 구할 수 있음 : O(1)


# 연결 리스트 (LinkedList)
- 배열의 시간복잡도를 생각해보면, 중간 삽입과 삭제의 시간복잡도가 O(N)이라는 것을 알 수 있습니다. → 삽입과 삭제를 매우 자주 해야 하는 상황이라면, 배열은 비효율적
- 탐색은 느리지만, 삽입과 삭제 연산은 매우 빠름 O(1) → 삽입과 삭제가 잦은 상황에서 자주 사용


## 싱글
- 탐색은 Head부터 Tail까지 일일이 확인해야 하므로 O(N) 시간 소요
- 단일 연결 리스트에서는 삽입, 삭제의 경우 인접한 곳의 선을 끊고 연결해주는 작업만 해주면 되므로 O(1)
- 단, 일방향으로만 진행되기 때문에 뒤로 돌아갈 수 없는 구조임에 유의 !

## 더블
- 탐색은 방향성이 양쪽에서 있다고는 하지만, 어쨌든 일일이 확인해야 하므로 O(N) 이라는 시간 소요
- 더블 연결 리스트에서는 삽입, 삭제의 경우 인접한 곳의 선을 끊고 연결해주는 작업만 해주면 되므로 O(1)
- 단, 데이터를 삽입, 삭제할 시에는 양쪽 화살표를 둘 다 적절하게 변경해줘야 함에 유의 !




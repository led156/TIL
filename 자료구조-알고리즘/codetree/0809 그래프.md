# 그래프
- 그래프
  + 노드, 정점 (Vertex) : 각각의 지점을 의미
  + 간선 (Edge) : 정점과 정점을 잇는 선을 의미
  + 무방향 그래프 / 방향 그래프 : 한쪽 방향으로만 갈 수 있는 길이 존재하는지 유무
  + 차수 : 정점 A와 연결된 정점의 수 (진입차수 (In-degree)와 진출차수 (Out-degree))
  + 사이클 : 특정 지점에서 출발해서 다시 본래 지점으로 돌아올 수 있다면
  + 연결 그래프 /  비 연결 그래프(단절 그래프) : 모든 정점들에 대해서 어느 두 정점을 잡아도 갈 수 있는 경로가 존재하는 그래프 유무

## 구현
- 정점의 수 $|V|$
- 간선의 수 $|E|$

### 인접 행렬
![image](https://github.com/user-attachments/assets/ee68038c-c0bd-484b-b3dc-8dedcbf4b573)
- 특정 정점 I, J 가 연결되어 있는지를 확인: $O(1)$
- 특정 정점과 연결되어 있는 모든 정점을 확인: $O(∣V∣)$
- 공간 복잡도: $O(∣V∣∗∣V∣)$

### 인접 리스트
![image](https://github.com/user-attachments/assets/f5fec0b4-ff1c-440d-bf61-4a89a5aa622a)
- 특정 정점 I, J 가 연결되어 있는지를 확인: O(min(degree(I),degree(J)))
- 특정 정점과 연결되어 있는 모든 정점을 확인:O(degree(X))
- 공간 복잡도: O(∣V∣+∣E∣)


# 그래프 탐색1
## DFS (Depth First Search, 깊이 우선 탐색)
- 재귀 + 방문 처리

## BFS (Breadth First Search, 너비 우선 탐색)
- 큐 + 방문 처리

### 최단거리
- BFS : BFS는 정의상 시작점으로부터 가까운 지점부터 방문하게 되기 때문에 가중치가 전부 동일한 그래프에서는 최단거리를 확실하게 구해줄 수 있음

### DFS, BFS의 시간복잡도 비교
- 어차피 모든 노드와 엣지를 방문하는 것이기 때문에 시간복잡도 자체는 O(∣V∣+∣E∣)로 동일합니다. 그러나 실제로 코드를 짜게되면 DFS가 약간 느린 편인데, 그 이유는 재귀함수의 오버헤드(함수를 동작시킬 때 발생하는 약간의 시간 지연을 의미합니다.) 때문입니다.


# 그래프 탐색2
## 최단거리
### 다익스트라 알고리즘 (Dijkstra Algorithm)
- 구현 : 우선순위 큐. $O(|E|\log{|V|})$ (우선순위 큐를 이용하지 않고 for 문을 이용해 최솟값을 찾는다면... $O({|V|}^2)$)
  + ```
    function dijkstra(graph, source)              // 그래프와 시작점 정보가 주어집니다.
    set Q = Queue()                           // 우선순위 큐를 만들어줍니다.

    for each vertex in graph                  // 그래프에 있는 모든 노드들에 대해
        set dist[v] = INF                     // 초기값을 전부 아주 큰 값으로 설정해주고 
        Q.push(v)                             // 우선순위큐에 각 노드를 넣어줍니다.

    set dist[source] = 0                      // 시작점에 대해서만 dist 값을 0으로 초기화해줍니다.
    while Q is not empty                      // 우선순위 큐가 비어있지 않을 때까지 반복합니다.
        set u = vertex in Q with min dist     // 우선순위 큐에서 dist값이 가장 작은 노드를 선택합니다.
        Q.remove(u)                           // 우선순위 큐에서 해당 노드를 제거해줍니다.

        for each neighbor v of u              // u번 노드와 연결된 노드들을 전부 살펴보면서
            set alt = dist[u] + length(u, v)  // 현재 dist값에 간선 가중치를 더한 값을 계산하여
            if alt < dist[v]                  // 기존 dist값보다 더 alt값이 작다면
                set dist[v] = alt             // dist값을 갱신해줍니다.
    ```
- 특정 시작점에서 다른 모든 정점으로 가는 최단거리를 각각 구해주는 알고리즘
- 우리가 다른 지점까지의 거리는 모르지만, A라는 지점까지 가는 최단거리는 확실히 안다고 가정해봅시다. 그렇다면 A를 거쳐 다른 지점을 갈 수 있다면, 우리는 현재 아는 정보로 "특정 지점까지 거리 = A까지 가는 거리 + A에서 특정 지점까지 소요되는 거리" 라고 추측할 수 있을 것 입니다.
- 음수 가중치가 있는 그래프 에서는 다익스트라가 올바르게 동작하지 않을 수 있습니다. 그 까닭은, 다익스트라에서는 dist중 가장 작은 값을 골랐을 때 그 값이 확실한 최단거리라는 보장이 되어야 하는데, 음수 가중치가 있으면 다시 골라졌던 정점에 도달하는 dist값이 더 작아질 수도 있기 때문에 최단거리임을 보장할 수 없게 됩니다.
  

### 플로이드 워셜 알고리즘 (Floyd-Warshall Algorithm)
- 구현 : for 문 구현 $O(V^3)$ (다익스트라를 다 돌리면 $O(VE\log{V})$, 간선이 많은 경우라면 효율적이지 않음)
  + ```
    function floyd(graph)
    set dist = |V| * |V| array initialized to INF  // 처음 dist 배열을 아주 큰 값인 INF로 초기화합니다.
    for each edge(u, v)                            // 주어진 그래프의 모든 간선에 대해
        dist[u][v] = length(u, v)                  // 각 간선의 가중치를 dist 배열에 적어줍니다.
    for k = 1 ... |V|                              // 확실하게 거쳐갈 정점을 1번부터 V번까지 순서대로 정의합니다.
        for i = 1 ... |V|                          // 고정된 k에 대해 모든 쌍 (i, j)를 살펴봅니다.
            for j = 1 ... |V|
                if dist[i][j] > dist[i][k] + dist[k][j]     // i에서 j로 가는 거리가 k를 경유해 가는 것이 더 좋다면
                    dist[i][j] = dist[i][k] + dist[k][j]    // dist[i][j]값을 갱신해줍니다.
    return dist

    ```
- 모든 쌍에 대해 최단거리를 구해야하는 상황에서 사용하기에 아주 좋은 알고리즘
- 정점의 수가 많지 않거나 모든 쌍에 대한 최단거리를 구해야만 할 때 사용하는 것이 좋고, 정점의 수가 많아진다면 필요한 지점들에 대해서만 다익스트라를 돌려서 해결하는 것이 좋음
- 아이디어는 다익스트라와 다소 유사한데, A → B로 가는 경로보다 A → X → B로 가는 경로가 더 짧다면 그것으로 갱신을 해주는 것입니다. dist[i][j] > dist[i][1] + dist[1][j]를 만족하는 경우 dist[i][j]에 dist[i][1] + dist[1][j]값을 넣어줌

## MST (최소 간선 트리)
- 그래프에서 최소한의 간선을 사용하여 그래프 내 모든 정점을 이어준 것 : Spanning Tree
  + 트리는 사이클이 없으며, 모든 모드들이 다 연결되어있음 (N개 정점에 N-1개 간선 존재)
- Minimum Spanning Tree : 최소한의 비용을 사용한 spanning tree


### [Union-Find]
- 여러 개의 원소가 있고, 여러 개의 집합이 있다고 가정합시다. 특정 원소가 어떤 집합에 속해있는지 확인하고, 특정 집합을 합쳐야 할 일이 있다면 Union-Find 자료구조를 사용
- uf 배열의 초기값은 자기 자신
  + union() 연산을 사용하면, 두 노드가 같은 곳에 속해있음을 표시 $O(\log{N})$
  + find() 연산을 사용하면, 두 노드 모두 부모 노드를 따라 올라 갈 수 있는데 까지 계속 올라감 $O(N)$
    * 경로 압축(Path Compression) -> $O(\log{N})$
  + ```
    function union(x, y)
      set X = find(x), Y = find(y)
      uf[X] = Y

    function find(x)
      if uf[x] == x        // x가 루트 노드라면
        return x           // x 값을 반환합니다.
      return find(uf[x])   // x가 루트 노드가 아니라면, x의 부모인 uf[x]에서 더 탐색을 진행합니다.

    function find(x)
      if uf[x] == x                 // x가 루트 노드라면
        return x                    // x 값을 반환합니다.
      set root_node = find(uf[x])   // x가 루트 노드가 아니라면, x의 부모인 uf[x]에서 더 탐색을 진행합니다.
      uf[x] = root_node             // 노드 x에 부모를 루트 노드로 설정해줍니다.
      return root_node              // 찾아낸 루트 노드를 반환합니다.

    ```

### 크루스컬 [간선]
- 가중치를 정렬. $O(E\log{E})$
- 가중치가 작은 간선부터 고른다. $O(E)$
  + MST에서 가장 중요한 성질은, 트리이기 때문에 절대 사이클이 생겨서는 안됨 → Union-Find를 이용해 사이클이 발생하지 않도록 함. $O(\log{N})$
- => 총 시간복잡도 = $O(E\log{E})$ +  $O(E\log{N})$ = $O(E\log{E})$
- ```
  function kruskal()
    mst = []                       // mst를 담을 배열입니다.
    sort edge[] by length          // 간선을 가중치 기준으로 오름차순 정렬합니다.
    uf = uf_init(|V|)              // uf 배열을 노드의 수 |V|만큼 초기화합니다.

    for E in edge[]                // 각각의 간선에 대해 
        u, v = E                   // 간선을 이루고 있는 두 노드 u, v를 보며
        if find(u) != find(v)      // u, v의 루트 노드가 다른 경우에만
            mst.push(E)            // mst에 해당 간선을 넣어주고
            union(u, v)            // u, v를 같은 루트 노드를 갖도록 만들어줍니다.
    
    return mst

  ```

### 프림 [지점]
- 한 지점에서 시작하여 점점 확장을 진행하는 방법
- dist[x]는 현재까지 만들어진 MST와 노드 x를 연결하기 위해 필요한 최소 비용으로 사용. (아주 큰 값으로 초기화, 시작점만 0)
- 거리 dist 내의 값들 중 최솟값을 골라줍니다. 이렇게 최솟값을 골라주는 과정을 프림 알고리즘에서도 역시 여러 번 반복하게 되므로 우선순위 큐를 사용
- ```
  function prim(graph)                          // 그래프와 시작점 정보가 주어집니다.
    set Q = Queue()                           // 우선순위 큐를 만들어줍니다.

    for each vertex in graph                  // 그래프에 있는 모든 노드들에 대해
        set dist[v] = INF                     // 초기값을 전부 아주 큰 값으로 설정해주고 
        Q.push(v)                             // 우선순위큐에 각 노드를 넣어줍니다.
    set source = |V|                          // 시작점을 임의로 마지막 노드로 설정합니다.
    set dist[source] = 0                      // 시작점 대해서만 dist 값을 0으로 초기화해줍니다.
    while Q is not empty                      // 우선순위 큐가 비어있지 않을 때까지 반복합니다.
        set u = vertex in Q with min dist     // 우선순위 큐에서 dist값이 가장 작은 노드를 선택합니다.
        Q.remove(u)                           // 우선순위 큐에서 해당 노드를 제거해줍니다.

        for each neighbor v of u              // u번 노드와 연결된 노드들을 전부 살펴보면서
            set alt = length(u, v)            // 간선 가중치를 살펴봅니다.
            if alt < dist[v]                  // 기존 dist값보다 더 alt값이 작다면
                set dist[v] = alt             // dist값을 갱신해줍니다.

  ```

## 위상정렬









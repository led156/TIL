# 동적계획법
- 동적계획법 : 큰 문제에 대한 답을 얻기 위해 동일한 문제이지만 크기가 더 작은 문제들을 먼저 해결한 뒤, 그 결과들을 이용해 큰 문제를 비교적 간단하게 해결하는 기법


## 메모이제이션 (Memoization) - 재귀 (탑다운)
![image](https://github.com/user-attachments/assets/91d29fb3-f737-4409-b9e1-decdd4881d5f)
- 값을 기록하고, 그 기록한 값을 참조하는 것 (중복 제거)
```
memo = [-1, -1, -1, ... ]

function fibbo(n)
    if (1) != -1
        return (2)
    if n <= 2
        (3) = 1
    else
        (4) = fibbo(n - 1) + fibbo(n - 2)

    return (5)
```


## Tabulation - for문 (바텀업)
```
set dp = [0, 0, 0, ...]

dp[1] = 1
dp[2] = 1

for i = 3 ... i <= n:
    dp[i] = dp[i - 1] + dp[i - 2]

print(dp[n])
```


### DP : subproblem 합치기
![image](https://github.com/user-attachments/assets/d8c79f56-d305-45c4-9562-a04cb7c8153c)

이 문제에서는 i번째를 끝으로 2×i 벽을 전부 타일로 채우는 경우를 생각해보면, 다음과 같이 끝에 세로로 하나를 붙이거나, 끝에 가로로 2개를 붙이는 경우만 존재한다는 것을 어렵지 않게 알 수 있습니다. 세로로 하나 붙이는 경우에는 남은 2×(i−1) 크기의 벽돌을 채우는 경우의 수와 같아지므로 dp[i - 1]가지가 되며, 가로로 2개를 붙이는 경우에는 남은 2×(i−2) 크기의 벽돌을 채우는 경우의 수와 같아지므로 dp[i - 2]가지가 됩니다.
즉 우리는 dp[i] = dp[i - 1] + dp[i - 2] 라는 점화식을 세울 수 있게 됩니다. 좀더 엄밀히는 다음을 만족하는 점화식을 얻게 됩니다.

dp[0] = 1, dp[1] = 1
dp[i] = dp[i - 1] + dp[i - 2] (i ≥ 2)


### DP : 격자 안에서 한 칸씩 전진하기
![image](https://github.com/user-attachments/assets/abf2e29c-83a3-46cb-8992-78e752926d62)


### DP : 조건에 맞게 선택적으로 전진하기 (LIS)
dp[i]를 마지막으로 고른 원소의 위치가 i인 부분 수열 중 최장 증가 부분 수열의 길이라 정의해보겠습니다. 조금 고민해보면 i번째 원소를 고르기 직전에 골라진 원소의 위치가 j였을 경우를 1부터 i - 1까지 전부 가정해보며 다음과 같은 점화식을 세워볼 수 있을 것입니다. dp[j]는 위치 j를 마지막으로 하는 최장 부분 수열의 길이를 들고 있을 것이기 때문에, dp[i]는 dp[j]로부터 답이 갱신되어야만 합니다. 단, 직전에 있던 숫자 a[j]가 현재 숫자인 a[i]보다는 작아야 증가 수열이 유지가 될 것이므로, 해당 경우들 중 최댓값을 구해야 합니다.



### [응용] 배낭 문제


### [심화] String Matching



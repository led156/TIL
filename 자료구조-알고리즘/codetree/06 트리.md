# 트리
- 트리 : 노드끼리 전부 연결되어 있으면서 사이클이 존재하지 않는 그래프
  + 노드 vertex: 각 지점을 의미합니다. 정점이라 부르기도 합니다.
  + 간선 edge: 두 노드를 연결하는 선을 의미합니다. 에지라고 부르기도 합니다.
  + 루트 노드 root: 트리에서 맨 꼭데기를 의미합니다. 위쪽 조직도를 보면, 루트 노드는 회사 대표가 되겠죠?
  + 부모, 자식 parent, child: 트리에서 연결된 두 노드의 관계를 의미하는데, 더 위쪽에 있는 노드를 부모 노드, 아래쪽에 있는 노드를 자식 노드라고 부릅니다.
  + 차수 degree: 특정 노드를 기준으로, 자식의 수가 얼마나 되는지 의미합니다.
  + 깊이 depth: 루트 노드와 얼마나 떨어져 있는지를 가리키는 말입니다.
  + 높이 height: 트리에서 깊이가 가장 깊은 노드의 깊이 혹은 1을 더한 값을 의미합니다. 코드트리에서는 앞으로 트리의 높이를 최대 깊이에 1을 더한 값으로 생각하도록 합시다.
  + 리프 노드 leaf: 자식을 갖고 있지 않은 노드를 의미합니다.

# 이진트리
- 자식의 수를 최대 2개로 제한
- 특정 노드의 위치가 $i$
  + 왼쪽 자식 위치 $i*2$, 오른쪽 자식 위치 $i*2+1$ : 자식들의 부모 위치 $i/2$
![image](https://github.com/user-attachments/assets/dad2f584-7ded-4bd0-b3c0-4c6847e48e25)


## 탐색
### Preorder Traversal 전위 탐색
- 부모 - 왼쪽 자식 - 오른쪽 자식 : 부모에 먼저 방문, 왼쪽 자식을 전부 순회하고 이후에 오른쪽 자식 방문
### Inorder Traversal 중위 탐색
- 왼쪽 자식 - 부모 - 오른쪽 자식 : 왼쪽 자식들을 먼저 전부 순회한 후, 부모를 방문하고 이후에 오른쪽 자식들을 방문
### Postorder Traversal 후위 탐색
- 왼쪽 자식 - 오른쪽 자식 - 부모 : 왼쪽 자식들을 먼저 전부 순회한 후, 오른쪽 자식들을 전부 순회, 마지막으로 부모를 방문


# 이진탐색트리 Binary Search Tree
- 특성 : 부모 왼쪽 방향에 있는 노드들은 전부 부모보다 값이 작아야 하고, 우측 방향에 있는 노드들은 전부 부모보다 값이 커야만 함.
- 탐색
  + 찾고자 하는 값 x와 일치하기 전까지 계속 이동.
  + 현재 노드에 적힌 값이 찾으려고 하는 값 x보다 크다면, x는 현재 노드의 왼쪽에 있다는 뜻 → node.left 이동, 작다면 → node.right 이동
- 삽입
  + null에 도달하기 전까지 계속 진행하여 값 x가 들어갈 위치 찾기. (null 위치를 찾으면 해당 위치에 넣기)
  + Case 1. 트리에 노드가 전혀 없는 경우입니다. 이 경우에는 parent값이 null일 것이며, 이진 탐색 트리의 root를 node(x)로 설정해줘야 합니다.
  + Case 2. parent에 적혀있는 값이 삽입하려는 값 x보다 더 큰 경우입니다. 이 경우에는 parent의 왼쪽에 node(x)를 넣어줘야 합니다.
  + Case 3. parent에 적혀있는 값이 삽입하려는 값 x보다 더 작은 경우입니다. 이 경우에는 parent의 오른쪽에 node(x)를 넣어줘야 합니다.
- 삭제
  + Case 1. 값을 찾았을 때 해당 노드(node)의 왼쪽 노드가 비어있다면, node의 오른쪽 노드를 위로 올려주면 됩니다.
  + Case 2. 값을 찾았을 때 해당 노드(node)의 오른쪽 노드가 비어있다면, node의 왼쪽 노드를 위로 올려주면 됩니다.
  + Case 3. 값을 찾았을 때 해당 노드(node)의 왼쪽 오른쪽 노드가 전부 채워져 있다면, successor를 찾아야 합니다. successor란 현재 노드를 기준으로 더 크면서 가장 작은 값을 갖는 노드를 뜻합니다. 예를 들어 다음 그림에서 노드 2의 successor는 노드 3 입니다.
    * ![image](https://github.com/user-attachments/assets/01015546-f3e9-47cd-975a-236632396cb6)
    * successor는 현재 node의 오른쪽 자식인 node.right를 시작으로 계속 내려갈 수 있는 만큼 왼쪽으로 내려가는 방식으로 비교적 간단하게 구할 수 있음.
    * ```
      function bst.search(x)
        set node = bst.root                     
        while node != null and node.value != x 
            if node.value > x                
                node = node.left           
            else                               
                node = node.right           
        
        return node            
    
    function bst.minimum(node)                  // node 하위 트리에서 최솟값을 구합니다.
        while node.left != null                 // node의 left가 null이 아니면 계속 내려갑니다.
            node = node.left
        return node                             // 최종 node의 위치를 반환합니다.
    
    function bst.delete(x)                      // x를 찾아 삭제하는 함수입니다.
        set node = bst.search(x)                // x 값을 찾습니다.
        
        if node.left == null                    // Case 1. node의 왼쪽 자식이 비어있다면
            move(node.right, node)              // 오른쪽 자식을 위로 올려줍니다.
        else if node.right == null              // Case 2. node의 오른쪽 자식이 비어있다면
            move(node.left, node)               // 왼쪽 자식을 위로 올려줍니다.
        else                                    // Case 3. 왼쪽 오른쪽 자식이 모두 채워져있다면
            set succ = bst.minimum(node.right)  // 해당 노드의 successor를 구합니다.
                                                // 이는 현재 노드의 오른쪽 자식에서 시작하여 계속 왼쪽으로 내려가는 것을
                                                // 반복하면 가능합니다.
            if succ == node.right               // 만약 successor가 현재 노드의 오른쪽 자식이라면 
                move(node.right, node)          // 오른쪽 자식을 위로 올려줍니다.
            else                                // 그렇지 않은 일반적인 경우라면
                node.value = succ.value         // node의 값을 successor의 값으로 대체시켜준 뒤,
                move(succ.right, succ)          // successor의 오른쪽 자식을 위로 끌어올려줍니다.

      ```

## 균형잡힌 이진 탐색 트리 $O(\log{N})$
- Red Black Tree나 AVL Tree 같이 특정 규칙에 따라 이진 탐색 트리를 관리하여, 균형잡힌 이진 탐색 트리를 유지할 수도 있음.
- 이를 이용하면 항상 트리의 높이를 $\log{N}$으로 유지시킬 수 있기 때문에 삽입, 삭제, 탐색 시간을 보장함. $O(\log{N})$


# Heap (작성중!)
- 완전 이진 트리로 구성됨 : 트리 모든 값이 왼쪽에서 순서대로 차 있는 것을 의미.
- 힙 종류 : max-heap, min-heap
  + max-heap : (루트 노드에는 전체 숫자 중 최댓값이 항상 들어 있음) 모든 노드에 대해 부모 노드가 자신의 자식 노드가 갖는 값보다 같거나 큰 경우
    * 생성 $O(n)$
    * 삭제, 삽입 $O(\log{n})$
    * 최댓값 구하기 $O(1)$
  + min-heap : (루트 노드에는 전체 숫자 중 최소값이 항상 들어 있음) 모든 노드에 대해 부모 노드가 자신의 자식 노드가 갖는 값보다 같거나 작은 경우
    * 생성 $O(n)$
    * 삭제, 삽입 $O(\log{n})$
    * 최소값 구하기 $O(1)$
- K번째 최대/최소값을 구할 수는 없음. 그때는 순차탐색이 더 편리함.
- 삭제는 루트 노드에서만 가능함.
- => 원소의 추가, 그리고 최댓값의 삭제가 빈번하게 일어나는 상황에서 현재 남아있는 원소들 중 최댓값을 빠르게 계속 얻고 싶은 경우에만 유용!!

- 문제
  + 힙은 $O(n)$에 만들 수 있다.
  + 힙에서 특정 원소를 삽입하는 데 걸리는 시간은 $O(\log{n})$이다.
  + 힙은 기준을 어떻게 세우느냐에 따라 루트에 최솟값을 담을 수도, 최댓값을 담을 수도 있다.
  + max-heap에서 최댓값을 찾는데 걸리는 시간은 항상 $O(1)$이다.
  + 노드 3개로 이루어져 있는 이진 탐색 트리는 절대 max-heap이 될 수 없다. → 이진 탐색 트리라는 조건 때문에. (예시: 1 2 3)
  + 힙은 값을 넣는 순서에 따라 맨 아래(리프 노드)의 값이 변할 수 있다.

## 힙 만들기
- heapify라는 것은, 현재 노드를 기준으로 이 노드가 heap 특성에 맞을 때까지 계속 밑으로 내려주는 과정
  + 현재 노드 위치를 i라고 한다면, 현재 노드, 왼쪽 자식(i * 2번째) 노드, 그리고 오른쪽 자식(i * 2 + 1번째) 노드 중 가장 큰 노드가 무엇인지 판단합니다. 이 세 노드 중 가장 큰 노드를 편의상 largest 노드라고 하겠습니다.
  + 만약 largest 노드가 현재 노드 i가 아닌 자식 노드라면, 현재 노드(i)와 해당 자식 노드(largest)의 값을 교환합니다. 교환 이후에는 다시 largest 위치에서 heapify를 진행합니다. 이렇듯 현재 노드가 heap 조건을 만족하도록 계속 내려주는 것을 재귀적으로 반복해줍니다.
  + 만약 largest 노드가 현재 노드 i라면, 종료합니다.




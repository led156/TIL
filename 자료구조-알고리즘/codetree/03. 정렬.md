# 버블 정렬 $O(N^2)$
![image](https://github.com/user-attachments/assets/54ab8842-9350-436e-b0b5-acd46a174999)

```
function bubble_sort(arr[])
  set len = arr.size
  
  for i = 0 ... i < len - 1
    for j = 0 ... j < len - 1 - i
      if arr[j] > arr[j + 1]
        set tmp = arr[j]
        arr[j] = arr[j + 1]
        arr[j + 1] = tmp
  
  return arr

```

1. 첫번째와 두번째 값을 비교하고, 두번째와 세번째 값을 비교하고, ... n-1번째와 n번째 값을 비교하며, 이 과정에서 순서가 맞지 않은 값을 서로 교환함.
- 한 바퀴 도는데, 시간복잡도는 $O(N)$. 최악의 경우 모든 자리의 수를 바꿔야 하므로 이를 반복한 $O(N^2)$

# 선택 정렬 $O(N^2)$
![image](https://github.com/user-attachments/assets/e1af4ba0-a401-49fc-ae24-7361c1307429)

```
function selection_sort(arr[])
  set len = arr.size
  for i = 0 ... i < len-1
    set min = i
    for j = i+1 ... j < len
      if arr[j] < arr[min]
        (1)
    set tmp = arr[i]
    arr[i] = (2)
    (3) = tmp
  
  return arr

```


1. 전체 값 중 가장 작은 값을 찾고, 해당 값을 맨 첫번째에 배치함
2. 첫번째 값을 제외하고 가장 작은 값을 찾아 두번째에 배치함
3. 두번째, 세번째, ... n-1번째 값을 제외하고 가장 작은 값을 찾아 정해진 위치에 배치함
- 선택 정렬의 경우 중간에 종료하지 않고 무조건 n-1, n-2, ..., 1번 비교 연산을 수행해야 함. → $n(n-1)/2$번의 연산 수행.


# 삽입 정렬 $O(N^2)$
[![image](https://github.com/user-attachments/assets/37075d26-f778-4f0e-a7a1-e859774c85c5)](https://gmlwjd9405.github.io/2018/05/06/algorithm-insertion-sort.html)

```
function insertion_sort(arr[])
  set size = arr.size
  for i = 1 ... i < size
    set j = (1)
    set key = arr[i]
    while j >= 0 && arr[(2)] > key
      arr[(3)] = arr[j]
      j--
    arr[(4)] = key
  return arr

```

1. 앞에 있는 모든 원소가 정렬이 되어 있다는 가정 하에서 현재 원소의 위치를 적절하게 집어넣는 정렬
2. 이를 모든 원소에 반복함.
- n개의 원소에 대해 값 삽입을 수행. 삽입은 n번째 원소일 때 최대 n-1개의 원소가 이동해야 함. → $n(n-1)/2$개의 원소가 이동

### 삽입 / 선택 / 거품 정렬 비교
|정렬간 속도 비교|(빠르다)>|>|>|
|--|--|--|--|
|정렬 분류|삽입 정렬|선택 정렬|거품 정렬|
|특징|앞 배열에 값을 삽입하는 알고리즘으로, 이미 정렬된 배열에 추가적으로 값을 몇개 추가하여 정렬하는 경우에 가장 좋은 성능을 보임 (반대로 정렬되어 있을 경우 성능이 많이 떨어짐)|배열의 상태와 상관 없이 항상 찾는 과정을 거치기 때문에 어떤 상황이던 동일한 시간을 보여줌|일반적으로 가장 느리지만, 정렬된 배열의 경우 sorted가 계속 true이기 때문에 시간이 매우 빨라짐|



# 기수 정렬 $O(k*n)$
![image](https://github.com/user-attachments/assets/1364428c-84c5-445d-8fdd-dd1780a389ad)

```
function radix_sort(arr, k)
  for pos = k - 1 ... pos >= 0:
    set arr_new = [10][]
    for i = 0 ... i < arr.size
      set digit = posth digit of arr[i]
      arr_new[digit].append(arr[i])

    set store_arr = []
    for i = 0 ... i < 10
      for j = 0 ... j < arr_new[i].size
        store_arr.append(arr_new[i][j])
  
    arr = store_arr

  return arr

```

- 맨 뒤에 있는 자릿수 부터 해당 자리수를 기준으로 정렬한 뒤, 점점 앞으로 이동하며 각 자리수를 기준으로 정렬하다가 최종적으로 가장 높은 자리수를 기준으로 정렬하는 방법
1. 가장 작은 자리 숫자(3번째)에 해당하는 위치에 순서대로 해당 숫자를 적어줌
2. 숫자들을 마지막 자리수에 맞게 쭉 적혀있는 숫자들을 순서대로 적어줌
3. 자릿수를 이동해 다시 위치에 순서대로 해당 숫자를 적어주고를 반복.
- 자릿수 k만큼 n개의 숫자를 탐색하므로 → $O(k*n)$

# 병합 정렬
[![image](https://github.com/user-attachments/assets/de206973-f01d-42e3-bee3-e45d24735e98)](https://gmlwjd9405.github.io/2018/05/08/algorithm-merge-sort.html)

```
set merged_arr = []           // 병합 이후의 결과를 담아줍니다.

function merge(arr[], low, mid, high)
  set i = low, j = mid + 1      // 각 리스트 내의 원소 위치를 잡습니다.

  set k = low                   // 병합 시 원소를 담을 위치를 유지합니다.
  while i <= mid && j <= high   // 두 리스트 내의 원소가 아직 남아있다면
    if arr[i] <= arr[j]          // 첫 번째 리스트 내의 원소가 더 작다면
      merged_arr[k] = arr[i]    // 해당 원소를 옮겨줍니다. 
      k += 1; i += 1
    else
      merged_arr[k] = arr[j]    // 그렇지 않다면 두 번째 리스트 내의
      k += 1; j += 1            // 원소를 옮겨줍니다.
  
  while i <= mid                // 아직 첫 번째 리스트 내 원소가 남아있다면
    merged_arr[k] = arr[i]      // 남은 원소들을 전부 옮겨줍니다.
    k += 1; i += 1

  while j <= high               // 아직 두 번째 리스트 내 원소가 남아있다면
    merged_arr[k] = arr[j]      // 남은 원소들을 전부 옮겨줍니다.
    k += 1; j += 1
  
  for k = low ... k <= high     // 병합된 리스트를 다시
    arr[k] = merged_arr[k]      // 원본 리스트에 옮겨줍니다.
  
  return arr 

```

- 배열의 길이가 1개가 될 때 까지 재귀적으로 쪼개기 → 쪼갠 배열을 합쳐가며 정렬된 배열로 만드는 방법. 분할 정복(Divide and Conquer) 사용
- 배열을 합치는 과정 : 두 배열의 원소를 하나씩 꺼내가면서 합치면 됨. $O(N)$
- 배열을 나누는 과정 : 초기 배열의 길이가 N이라면 계속 2로 나눠서 각 요소의 길이가 1이 되어야 하므로 $\log{N}$번 반복함.
- 즉, 총 $O(N\log{N})$ 시간복잡도



# 퀵 정렬
[![image](https://github.com/user-attachments/assets/7e3b1466-4d02-4c51-b25a-94580700763c)
](https://gmlwjd9405.github.io/2018/05/10/algorithm-quick-sort.html)




# 힙 정렬


# Sorted 정렬


# In-Place 정렬








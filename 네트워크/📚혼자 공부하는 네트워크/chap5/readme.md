# 05-1. DNS와 자원
## 도메인 네임과 네임 서버
- IP주소를 모두 기억하고 있기는 어려움, 따라서 상대 호스트를 특정하기 위해 도메인 네임을 많이 사용함.
- 도메인 네임 : 호스트의 IP 주소와 대응되는 문자열 형태의 호스트 특정 정보 (www.naver.com , ...)
  + 도메인 네임은 점(.)을 기준으로 계층적으로 분류됨.
  + 최상단에 루트 도메인(root domain), 그 다음 단계에 최상위 도메인(TLD; Top-Level Domain), 계속 그다음 단계 도메인이 있음.
  + ![image](https://github.com/user-attachments/assets/61610d05-98ea-428f-95e7-6e5434cf7675)

- 네임 서버(DNS 서버) : 도메인 네임과 IP 주소를 관리하는 서버.
  + DNS(Domain Name System) : 도메인 네임 시스템을 이용할 수 있도록 하는 애플리케이션 계층 프로토콜

## 계층적 네임 서버
- 리졸빙 : IP 주소를 모르는 상태에서 도메인 네임에 대응되는 IP 주소를 알아내는 과정
  + DNS 캐시 : 네임 서버들이 기존에 응답받은 결과를 임시로 저장했다가 추후 같은 질의에 이를 활용하는 경우
![image](https://github.com/user-attachments/assets/1366045f-714a-4bc4-b886-80a548b763c0)
- 로컬 네임 서버(DNS Resolver)
  + 클라이언트와 맞닿아, 가장 먼저 찾게 되는 네임 서버
  + 클라이언트가 로컬 네임 서버의 주소를 알고 있어야 하므로, ISP에서 할당해 주는 경우가 많음 -> 공개 DNS 서버를 이용할 수도 있음
- 루트 네임 서버(Root Server)
  + 로컬 네임 서버가 대응되는 IP 주소를 모를 때 해당 루트 네임 서버에 질의하게 됨.
  + 루트 도메인을 관장하는 네임 서버로, 질의에 대해 TLD 네임 서버의 IP 주소를 반환함.
- TLD 네임 서버
  + TLD를 관리하는 네임 서버로, 질의에 대해 하위 도메인 네임을 관리하는 네임 서버 주소를 반환함.
  + 하위 도메인 네임 서버 : 그보다 하위 도메인 네임을 관리하는 네임 서버 주소 반환 ...
- 책임 네임 서버(authoritative server)
  + 특정 도메인 영역을 관리하는 네임 서버
  + 로컬 네임 서버가 마지막으로 질의하는 네임 서버로, 다른 네임 서버에 떠넘기지 않고 곧바로 답함.
  
### 재귀적 질의 recursive query
- 클라이언트가 로컬 네임 서버에 도메인 네임을 질의하면, 로컬 네임 서버가 루트 네임 서버에게 질의하고, 루트 네임 서버가 TLD 네임 서버에게 질의하고, TLD 네임 서버가 다음 단계에 질의하는 과정을 반복하며 최종 응답 결과를 역순으로 전달받는 방식

### 반복적 질의 iterative query
- 클라이언트가 로컬 네임 서버에게 IP 주소를 알고 싶은 도메인 네임을 질의하면, 로컬 네임 서버는 루트 도메인 서버에게 질의해서 다음으로 질의할 네임 서버의 주소를 응답받고, 다음으로 TLD 네임 서버에게 질의해서 다음으로 질의할 네임 서버의 주소를 응답받는 과정을 반복하다가 최종 응답 결과를 클라이언트에게 알려 주는 방식

![image](https://github.com/user-attachments/assets/c66eec97-eca1-4fd8-b9ce-4cbe3ed0652a)

## 자원을 식별하는 URI
- 자원(resource) : 네트워크상의 메시지를 통해 주고받는 대상
- URI(Uniform Resource Identifier) : 자원을 식별할 수 있는 정보
  + URL(Uniform Resource Locator) : 위치를 이용해 자원을 식별
  + URN(Uniform Resource Name) : 이름을 이용해 자원을 식별


### URL
![image](https://github.com/user-attachments/assets/0de78553-04c5-4d66-b37c-c14b5d05b541)
- scheme
  + 자원에 접근하는 방법 (일반적으로 사용할 프로토콜)
- authority
  + 호스트를 특정할 수 있느 정보 (IP주소 / 도메인 네임)
  + 콜론(:) 뒤에 포트 번호를 덧붙일 수도 있음
- path
  + 자원이 위치한 경로
  + 슬래시(/)를 기준으로 계층적으로 표현되고, 최상위 경로 또한 슬래시로 표현됨
  + ![image](https://github.com/user-attachments/assets/74706db8-3b99-4a1f-a0fc-0aa77c022e1d)
- query
  + 쿼리 문자열(query string), 쿼리 파라미터(query parameter) :
    * 물음표(?)로 시작되는 <키=값> 형태의 데이터로, 앰퍼샌드(&)를 사용하여 여러 쿼리 문자열을 연결할 수 있음.
    * `http://example.com/random/path?query=value&query2=value2`
- fragment
  + 자원의 한 조각을 가리키기 위한 정보
  + 예시) HTML 자원의 특정 부분을 가리키게 할 수 있음

### URN
- 자원의 위치는 언제나 변할 수 있기 때문에, 자원에 고유한 이름을 붙여서 이름 기반 식별이 가능함 : URN (예시; 도서의 ISBN)


# DNS 레코드 타입
- DNS 자원 레코드 / DNS 레코드
- |레코드 유형|설명|
  |----|----|
  |A|특정 호스트에 대한 도메인 네임과 IPv4 주소와의 대응 관계|
  |AAAA|특정 호스트에 대한 도메인 네임과 IPv6 주소와의 대응 관계|
  |CNAME|호스트 네임에 대한 별칭 지정|
  |NS|특정 호스트의 IP 주소를 찾을 수 있는 네임 서버|
  |MX|해당 도메인과 연동되어 있는 메일 서버|

- ![image](https://github.com/user-attachments/assets/79a3f87b-c529-48bc-bb1f-1545c2087344)
  + example.com.이 1.2.3.4에 대응되어 있다는 것을 보여줌.
  + 네임 서버에 example.com.을 질의하면 1.2.3.4를 응답받을 수 있음.
 
- ![image](https://github.com/user-attachments/assets/f4d7a8e5-4275-4e10-8d23-3c62f3aebadc)
  + example.com.에 대한 별칭으로 www.example.com.을 사용하겠다는 의미.
  + www.example.com.을 질의하면 같은 IP 주소인 1.2.3.4를 응답받게 됨.

# 05-2. HTTP
## HTTP
- HTTP의 중요한 설계 목표 : 확장성scalability, 견고성robustness

### 특성1 : 요청-응답 프로토콜
- HTTP는 클라이언트-서버 구조 기반의 요청-응답 프로토콜
  + 같은 HTTP 메시지일지라도 HTTP 요청 메시지와 HTTP 응답 메시지는 메시지 형태가 다름
- 클라이언트는 HTTP 요청 메시지를 통해 서버의 자원을 요청할 수 있고, 서버는 HTTP 응답 메시지로 요청받은 자원에 대해 응답할 수 있음.

### 특성2 : 미디어 독립적 프로토콜
- HTTP로 주고받을 수 있는 자원은 한계가 있지 않음. http는 수단(인터페이스)의 역할을 수행하여, 다양한 종류의 자원을 주고받을 수 있음.
- 미디어 타입 : 메시지로 주고받는 자원의 종류 (일종의 웹 세상의 확장자와 같은 개념)
  + `타입/서브타입` 형식.
    * 타입 : 데이터의 유형.
    * 서브타입 : 주어진 타입에 대한 세부 유형.
  + 종류는 매우 다양하며, 필요에 따라 새로운 미디어 타입을 등록할 수도 있음.
  + `타입/서브타입;매개변수=값`도 가능.

### 특성3 : 스테이트리스 프로토콜
- HTTP는 상태를 유지하지 않는 스테이트리스 프로토콜
  + 서버가 HTTP 요청을 보낸 클라이언트와 관련된 상태를 기억하지 않음. (= 클라이언트의 모든 HTTP 요청은 기본적으로 독립적인 요청으로 간주됨)
  + 따라서 클라이언트는 같은 응답 메시지를 여러 번 받을 수 있음
- 이는 일반적으로 많은 클라이언트와 동시에 상호 작용하는 HTTP 서버에 장점이 될 수 있음
  + 동시에 처리해야 할 요청 메시지의 수는 수천 개가 될 수도 있고, 많게는 수백만 개가 될 수도 있음. 이런 상황에서 모든 클라이언트의 상태 정보를 유지하는 것은 서버에 큰 부담이 됨.
  + 또한 여러 대의 서버로 구성되있을 경우, 모든 서버가 모든 클라이언트의 상태를 유지할 경우 클라이언트는 여러 서버를 동시에 이용하기 어려워짐. (모든 서버가 모든 클라이언트의 상태 정보를 공유하는 작업은 복잡하기 때문)
  + 그리고 클라이언트는 자신의 상태를 기억하는 특정 서버하고만 상호 작용할 수 있게 되어, 특정 서버에 종속될 수 있음. 이때 해당 서버에 문제가 발생하면 클라이언트의 통신 내역을 잃어버릴 수 있는 상황이 발생할 수 있음.
- => 상태를 유지하지 않는 스테이트리스 특성은 필요하다면 언제든 쉽게 서버를 추가할 수 있기 때문에 확장성이 높고, 서버 중 하나에 문제가 생겨도 쉽게 다른 서버로 대체가 가능하기 때문에 견고성이 높음.


### 특성4 : 지속 연결(persistent connection) 프로토콜
![image](https://github.com/user-attachments/assets/dfb64f72-5570-49c3-8d11-0d0c0ad1f74f)
- 지속 연결 / 킵 얼라이브 keep-alive
  + 하나의 TCP 연결상에서 여러 개의 요청-응답을 주고받을 수 있는 기술임.
  + 매번 새롭게 연결을 수립하고 종료해야 하는 비지속 연결에 비해 더 빠르게 여러 HTTP 요청과 응답을 처리할 수 있음.
 
## HTTP 메시지 구조
![image](https://github.com/user-attachments/assets/30dd4bcb-b258-48a4-a595-47c2a93ef84a)
![image](https://github.com/user-attachments/assets/119561ac-7fd8-4080-8a28-31782069a1dc)


- 시작 라인 (없거나 여러 개 있을 수 있음)
  + HTTP 요청 메시지일 경우 `요청 라인`(request-line)이 됨
    * 메서드 method : 클라이언트가 서버의 자원(요청 대상)에 대해 수행할 작업의 종류를 나타냄
    * 요청 대상 request-target : HTTP 요청을 보낼 서버의 자원을 의미함
    * HTTP 버전 HTTP-version : 사용된 HTTP 버전을 의미 `HTTP/1.1`
  + HTTP 응답 메시지일 경우 `상태 라인`이 됨
    * 상태 코드 status code : 요청에 대한 결과를 나타내는 세 자리 정수 (클라이언트는 이를 통해 요청이 어떻게 처리되었는지 판단 가능)
    * 이유 구문 reason phrase : 상태 코드에 대한 문자열 형태의 설명을 의미함. `200 OK`, `404 Not Found`
- 필드 라인 (0개 이상의 HTTP 헤더가 명시)
  + HTTP 통신에 필요한 부가 정보인 HTTP 헤더가 포함됨.
  + 콜론(:)을 기준으로 헤더 이름과 하나 이상의 헤더 값으로 구성됨.
- 메시지 본문 (없을 수 있음)


  


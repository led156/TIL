# 05-1. DNS와 자원
## 도메인 네임과 네임 서버
- IP주소를 모두 기억하고 있기는 어려움, 따라서 상대 호스트를 특정하기 위해 도메인 네임을 많이 사용함.
- 도메인 네임 : 호스트의 IP 주소와 대응되는 문자열 형태의 호스트 특정 정보 (www.naver.com , ...)
  + 도메인 네임은 점(.)을 기준으로 계층적으로 분류됨.
  + 최상단에 루트 도메인(root domain), 그 다음 단계에 최상위 도메인(TLD; Top-Level Domain), 계속 그다음 단계 도메인이 있음.
  + ![image](https://github.com/user-attachments/assets/61610d05-98ea-428f-95e7-6e5434cf7675)

- 네임 서버(DNS 서버) : 도메인 네임과 IP 주소를 관리하는 서버.
  + DNS(Domain Name System) : 도메인 네임 시스템을 이용할 수 있도록 하는 애플리케이션 계층 프로토콜

## 계층적 네임 서버
- 리졸빙 : IP 주소를 모르는 상태에서 도메인 네임에 대응되는 IP 주소를 알아내는 과정
  + DNS 캐시 : 네임 서버들이 기존에 응답받은 결과를 임시로 저장했다가 추후 같은 질의에 이를 활용하는 경우
![image](https://github.com/user-attachments/assets/1366045f-714a-4bc4-b886-80a548b763c0)
- 로컬 네임 서버(DNS Resolver)
  + 클라이언트와 맞닿아, 가장 먼저 찾게 되는 네임 서버
  + 클라이언트가 로컬 네임 서버의 주소를 알고 있어야 하므로, ISP에서 할당해 주는 경우가 많음 -> 공개 DNS 서버를 이용할 수도 있음
- 루트 네임 서버(Root Server)
  + 로컬 네임 서버가 대응되는 IP 주소를 모를 때 해당 루트 네임 서버에 질의하게 됨.
  + 루트 도메인을 관장하는 네임 서버로, 질의에 대해 TLD 네임 서버의 IP 주소를 반환함.
- TLD 네임 서버
  + TLD를 관리하는 네임 서버로, 질의에 대해 하위 도메인 네임을 관리하는 네임 서버 주소를 반환함.
  + 하위 도메인 네임 서버 : 그보다 하위 도메인 네임을 관리하는 네임 서버 주소 반환 ...
- 책임 네임 서버(authoritative server)
  + 특정 도메인 영역을 관리하는 네임 서버
  + 로컬 네임 서버가 마지막으로 질의하는 네임 서버로, 다른 네임 서버에 떠넘기지 않고 곧바로 답함.
  
### 재귀적 질의 recursive query
- 클라이언트가 로컬 네임 서버에 도메인 네임을 질의하면, 로컬 네임 서버가 루트 네임 서버에게 질의하고, 루트 네임 서버가 TLD 네임 서버에게 질의하고, TLD 네임 서버가 다음 단계에 질의하는 과정을 반복하며 최종 응답 결과를 역순으로 전달받는 방식

### 반복적 질의 iterative query
- 클라이언트가 로컬 네임 서버에게 IP 주소를 알고 싶은 도메인 네임을 질의하면, 로컬 네임 서버는 루트 도메인 서버에게 질의해서 다음으로 질의할 네임 서버의 주소를 응답받고, 다음으로 TLD 네임 서버에게 질의해서 다음으로 질의할 네임 서버의 주소를 응답받는 과정을 반복하다가 최종 응답 결과를 클라이언트에게 알려 주는 방식

![image](https://github.com/user-attachments/assets/c66eec97-eca1-4fd8-b9ce-4cbe3ed0652a)

## 자원을 식별하는 URI
- 자원(resource) : 네트워크상의 메시지를 통해 주고받는 대상
- URI(Uniform Resource Identifier) : 자원을 식별할 수 있는 정보
  + URL(Uniform Resource Locator) : 위치를 이용해 자원을 식별
  + URN(Uniform Resource Name) : 이름을 이용해 자원을 식별


### URL
![image](https://github.com/user-attachments/assets/0de78553-04c5-4d66-b37c-c14b5d05b541)
- scheme
  + 자원에 접근하는 방법 (일반적으로 사용할 프로토콜)
- authority
  + 호스트를 특정할 수 있느 정보 (IP주소 / 도메인 네임)
  + 콜론(:) 뒤에 포트 번호를 덧붙일 수도 있음
- path
  + 자원이 위치한 경로
  + 슬래시(/)를 기준으로 계층적으로 표현되고, 최상위 경로 또한 슬래시로 표현됨
  + ![image](https://github.com/user-attachments/assets/74706db8-3b99-4a1f-a0fc-0aa77c022e1d)
- query
  + 쿼리 문자열(query string), 쿼리 파라미터(query parameter) :
    * 물음표(?)로 시작되는 <키=값> 형태의 데이터로, 앰퍼샌드(&)를 사용하여 여러 쿼리 문자열을 연결할 수 있음.
    * `http://example.com/random/path?query=value&query2=value2`
- fragment
  + 자원의 한 조각을 가리키기 위한 정보
  + 예시) HTML 자원의 특정 부분을 가리키게 할 수 있음

### URN
- 자원의 위치는 언제나 변할 수 있기 때문에, 자원에 고유한 이름을 붙여서 이름 기반 식별이 가능함 : URN (예시; 도서의 ISBN)


# DNS 레코드 타입
- DNS 자원 레코드 / DNS 레코드
- |레코드 유형|설명|
  |----|----|
  |A|특정 호스트에 대한 도메인 네임과 IPv4 주소와의 대응 관계|
  |AAAA|특정 호스트에 대한 도메인 네임과 IPv6 주소와의 대응 관계|
  |CNAME|호스트 네임에 대한 별칭 지정|
  |NS|특정 호스트의 IP 주소를 찾을 수 있는 네임 서버|
  |MX|해당 도메인과 연동되어 있는 메일 서버|

- ![image](https://github.com/user-attachments/assets/79a3f87b-c529-48bc-bb1f-1545c2087344)
  + example.com.이 1.2.3.4에 대응되어 있다는 것을 보여줌.
  + 네임 서버에 example.com.을 질의하면 1.2.3.4를 응답받을 수 있음.
 
- ![image](https://github.com/user-attachments/assets/f4d7a8e5-4275-4e10-8d23-3c62f3aebadc)
  + example.com.에 대한 별칭으로 www.example.com.을 사용하겠다는 의미.
  + www.example.com.을 질의하면 같은 IP 주소인 1.2.3.4를 응답받게 됨.

# 05-2. HTTP
## HTTP
- HTTP의 중요한 설계 목표 : 확장성scalability, 견고성robustness

### 특성1 : 요청-응답 프로토콜
- HTTP는 클라이언트-서버 구조 기반의 요청-응답 프로토콜
  + 같은 HTTP 메시지일지라도 HTTP 요청 메시지와 HTTP 응답 메시지는 메시지 형태가 다름
- 클라이언트는 HTTP 요청 메시지를 통해 서버의 자원을 요청할 수 있고, 서버는 HTTP 응답 메시지로 요청받은 자원에 대해 응답할 수 있음.

### 특성2 : 미디어 독립적 프로토콜
- HTTP로 주고받을 수 있는 자원은 한계가 있지 않음. http는 수단(인터페이스)의 역할을 수행하여, 다양한 종류의 자원을 주고받을 수 있음.
- 미디어 타입 : 메시지로 주고받는 자원의 종류 (일종의 웹 세상의 확장자와 같은 개념)
  + `타입/서브타입` 형식.
    * 타입 : 데이터의 유형.
    * 서브타입 : 주어진 타입에 대한 세부 유형.
  + 종류는 매우 다양하며, 필요에 따라 새로운 미디어 타입을 등록할 수도 있음.
  + `타입/서브타입;매개변수=값`도 가능.

### 특성3 : 스테이트리스 프로토콜
- HTTP는 상태를 유지하지 않는 스테이트리스 프로토콜
  + 서버가 HTTP 요청을 보낸 클라이언트와 관련된 상태를 기억하지 않음. (= 클라이언트의 모든 HTTP 요청은 기본적으로 독립적인 요청으로 간주됨)
  + 따라서 클라이언트는 같은 응답 메시지를 여러 번 받을 수 있음
- 이는 일반적으로 많은 클라이언트와 동시에 상호 작용하는 HTTP 서버에 장점이 될 수 있음
  + 동시에 처리해야 할 요청 메시지의 수는 수천 개가 될 수도 있고, 많게는 수백만 개가 될 수도 있음. 이런 상황에서 모든 클라이언트의 상태 정보를 유지하는 것은 서버에 큰 부담이 됨.
  + 또한 여러 대의 서버로 구성되있을 경우, 모든 서버가 모든 클라이언트의 상태를 유지할 경우 클라이언트는 여러 서버를 동시에 이용하기 어려워짐. (모든 서버가 모든 클라이언트의 상태 정보를 공유하는 작업은 복잡하기 때문)
  + 그리고 클라이언트는 자신의 상태를 기억하는 특정 서버하고만 상호 작용할 수 있게 되어, 특정 서버에 종속될 수 있음. 이때 해당 서버에 문제가 발생하면 클라이언트의 통신 내역을 잃어버릴 수 있는 상황이 발생할 수 있음.
- => 상태를 유지하지 않는 스테이트리스 특성은 필요하다면 언제든 쉽게 서버를 추가할 수 있기 때문에 확장성이 높고, 서버 중 하나에 문제가 생겨도 쉽게 다른 서버로 대체가 가능하기 때문에 견고성이 높음.


### 특성4 : 지속 연결(persistent connection) 프로토콜
![image](https://github.com/user-attachments/assets/dfb64f72-5570-49c3-8d11-0d0c0ad1f74f)
- 지속 연결 / 킵 얼라이브 keep-alive
  + 하나의 TCP 연결상에서 여러 개의 요청-응답을 주고받을 수 있는 기술임.
  + 매번 새롭게 연결을 수립하고 종료해야 하는 비지속 연결에 비해 더 빠르게 여러 HTTP 요청과 응답을 처리할 수 있음.
 
## HTTP 메시지 구조
![image](https://github.com/user-attachments/assets/30dd4bcb-b258-48a4-a595-47c2a93ef84a)
![image](https://github.com/user-attachments/assets/119561ac-7fd8-4080-8a28-31782069a1dc)


- 시작 라인 (없거나 여러 개 있을 수 있음)
  + HTTP 요청 메시지일 경우 `요청 라인`(request-line)이 됨
    * 메서드 method : 클라이언트가 서버의 자원(요청 대상)에 대해 수행할 작업의 종류를 나타냄
    * 요청 대상 request-target : HTTP 요청을 보낼 서버의 자원을 의미함
    * HTTP 버전 HTTP-version : 사용된 HTTP 버전을 의미 `HTTP/1.1`
  + HTTP 응답 메시지일 경우 `상태 라인`이 됨
    * 상태 코드 status code : 요청에 대한 결과를 나타내는 세 자리 정수 (클라이언트는 이를 통해 요청이 어떻게 처리되었는지 판단 가능)
    * 이유 구문 reason phrase : 상태 코드에 대한 문자열 형태의 설명을 의미함. `200 OK`, `404 Not Found`
- 필드 라인 (0개 이상의 HTTP 헤더가 명시)
  + HTTP 통신에 필요한 부가 정보인 HTTP 헤더가 포함됨.
  + 콜론(:)을 기준으로 헤더 이름과 하나 이상의 헤더 값으로 구성됨.
- 메시지 본문 (없을 수 있음)

## HTTP 메서드

|HTTP 메서드|설명|
|---|---|
|GET|자원을 습득하기 위한 메서드|
|HEAD|GET과 동일하나, 헤더만을 응답받는 메서드|
|POST|서버로 하여금 특정 작업을 처리하게끔 하는 메서드|
|PUT|자원을 대체하기 위한 메서드|
|PATCH|자원에 대한 부분적 수정을 위한 메서드|
|DELETE|자원을 삭제하기 위한 메서드|
|CONNECT|자원에 대한 양방향 연결을 시작하는 메서드|
|OPTIONS|사용 가능한 메서드 등 통신 옵션을 확인하는 메서드|
|TRACE|자원에 대한 루프백 테스트를 수행하는 메서드|

### GET - 가져다주세요
- 특정 자원을 조회할 때 사용되는 메서드
- 웹 브라우저를 통해 조회하는 자원은 대부분 GET 요청 메시지에 대한 응답임.
  + 따라서 요청 대상, Host 헤더가 필요함.
  + 요청 대상 : 일반적으로 요청할 자원에 대한 쿼리가 포함된 경로가 명시됨
  + Host 헤더 : 요청을 보낼 호스트가 명시됨
1. 요청 메시지 : GET 메서드에 요청 메시지 본문을 포함시키는 것은 바람직하지 않음
```
GET /example-page HTTP/1.1
Host: www.example.com
Accept: *
```
2. 요청 메시지 : GET 요청 메시지에서는 메시지 본문보다 다음 예시처럼 쿼리 문자열이 사용되는 경우가 많음
```
GET /index.html?name1=value1&name2=value2 HTTP/1.1
Host: www.example.com
Accept: *
```
3. 응답 메시지
```
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 1234

<!DOCTYPE html>
...
```

### HEAD - 헤더만 가져다주세요
- GET과 동일한 역할을 하지만, 응답 메시지에 메시지 본문이 포함되지 않음. ➡️ 응답 메시지의 헤더만을 반환함
1. 요청 메시지
```
GET /example-page HTTP/1.1
Host: www.example.com
Accept: *
```
2. 응답 메시지
```
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 1234
```

### POST - 처리해 주세요
- 서버로 하여금 특정 작업을 처리하도록 요청하는 메서드 / 주로 클라이언트가 서버에 새로운 자원을 생성하고자 할 때 사용됨
  + 만약 성공적으로 POST 요청이 처리되어 새로운 자원이 생성되면 서버는 응답 메시지의 Location 헤더를 통해 새로 생성된 자원의 위치를 클라이언트에게 알려 줄 수 있음.
- 메시지 본문 : 처리할 대상
1. 요청 메시지
```
POST /posting HTTP/1.1
Host: example.com
...헤더 후략...

{
  "Id": 1,
  "Title": "오늘도 즐거운 날입니다",
  "Contents": "재미있는 글 보고 가세요~"
}
```
2. 응답 메시지
```
HTTP/1.1 201 Created
Content-Type: application/json
Content-Length: 100
Date: Mon, 14 Oct 2024 16:35:00 PST
Location: /posting/1 (생성된 위치)

{
  "Id": 1,
  "Title": "오늘도 즐거운 날입니다",
  "Contents": "재미있는 글 보고 가세요~"
}
```

### PUT - 덮어써 주세요
- 요청 자원이 없다면 메시지 본문으로 자원을 새롭게 생성하거나, 이미 자원이 존재한다면 메시지 본문으로 자원을 완전히 대체하는 메서드임.

### PATCH - 일부 수정해 주세요
- PUT 메서드는 덮어쓰기, 완전한 대체에 가깝다면 PATCH는 부분적 수정에 가까움.
![image](https://github.com/user-attachments/assets/217670e4-a427-4024-903a-de97a0ad7379)

### DELETE - 삭제해 주세요
- 특정 자원을 삭제하고 싶을 때 사용하는 메서드임
1. 요청 메시지
```
DELETE /texts/a.txt HTTP/1.1
Host: example.com
```

### API 문서
- 어떤 URI(URL)에 어떤 메서드로 요청을 받았을 때 서버가 어떻게 행동해야 하는지 설계하는 것은 오로지 개발자의 몫임.
  + 어떤 메서드는 구현할 수도 있고, 어떤 메서드는 구현하지 않을 수도 있음
  + 따라서 같은 URL에 대한 요청일지라도 사용된 메서드가 다르면 각기 다른 요청으로 간주하기 때문에, 때로는 같은 URL에 대해 메서드별 동작을 여러 개 구현할 수도 있음


## HTTP 상태 코드
- 상태 코드 : 요청에 대해 결과를 나타내는 세 자리 정수

|상태 코드|설명|
|---|---|
|100번대(100~199)|정보성 상태 코드|
|200번대(200~299)|성공 상태 코드|
|300번대(300~399)|리다이렉션 상태 코드|
|400번대(400~499)|클라이언트 에러 상태 코드|
|500번대(500~599)|서버 에러 상태 코드|

### 200번대: 성공 상태 코드
|상태 코드|상태 텍스트|한국어 뜻|서버 측면에서의 의미|
|---|---|---|---|
|2XX|Success|성공|클라이언트가 요청한 동작을 수신하여 이해하였고 승낙하였으며 성공적으로 처리하였다.|
|200|OK|성공|서버가 요청을 성공적으로 처리하였다.|
|201|Created|생성됨|요청이 처리되어서 새로운 리소스가 생성되었다. <br>응답 헤더 Location에 새로운 리소스의 절대 URI를 기록합니다.|
|202|Accepted|허용됨|요청은 접수하였지만, 처리가 완료되지 않았다. <br>응답 헤더의 Location, Retry-After를 참고하여 클라이언트는 다시 요청을 보냅니다.|
|204|No Content|콘텐츠 없음|처리를 성공하였지만, 클라이언트에게 돌려줄 콘텐츠가 없다. <br>응답에는 헤더만 있고 바디는 없습니다. DELETE 요청에 대한 응답에 많이 사용됩니다.|

### 300번대: 리다이렉션 상태 코드

|상태 코드|상태 텍스트|한국어 뜻|서버 측면에서의 의미|
|---|---|---|---|
|3XX|Redirection|리다이렉션|클라이언트는 요청을 마치기 위해 추가 동작을 취해야 한다.|
|301|Moved Permanently|영구 이동|영구적 리다이렉션: 지정한 리소스가 새로운 URI로 이동하였다. <br>이동할 곳의 새로운 URI는 응답 헤더 Location에 기록합니다. (재요청 메서드 변경될 수 있음)|
|302|Found|다른 위치 찾음|요청한 리소스를 다른 URI에서 찾았다. <br>요청한 URI가 없으므로 클라이언트 메소드를 그대로 유지한 채 응답 헤더 Location에 표시된 다른 URI로 요청을 재송신할 필요가 있습니다. <br>302의 의미를 정확하게 개선해서 307을 정의하였으므로 이 응답 코드의 사용은 권장하지 않습니다.|
|303|See Other|일시적 리다이렉션: 다른 위치 보기	다른 위치로 요청하라. <br>요청에 대한 처리 결과를 응답 헤더 Location에 표시된 URI에서 GET으로 취득할 수 있습니다. 브라우저의 폼 요청을 POST로 처리하고 그 결과 화면으로 리다이렉트시킬 때 자주 사용하는 응답 코드입니다.|
|304|Not Modified|수정되지 않음|마지막 요청 이후 요청한 페이지는 수정되지 않았다.<br>If-Modified-Since와 같은 조건부 GET 요청일 때 지정한 리소스가 갱신되지 않았음을 알려 줍니다. 이 응답 코드에는 바디가 없습니다.|
|307|Temporary Redirect|임시 리다이렉션|일시적 리다이렉션: 임시로 리다이렉션 요청이 필요하다. <br>요청한 URI가 없으므로 클라이언트 메소드를 그대로 유지한 채 응답 헤더 Location에 표시된 다른 URI로 요청을 재송신할 필요가 있습니다. 클라이언트는 향후 요청 시 원래 위치를 계속 사용해야 합니다. 302의 의미를 정확하게 재정의해서 HTTP/1.1의 307 응답으로 추가되었습니다.|
|308|Permanent Redirect|영구 이동|영구적 리다이렉션: 지정한 리소스가 새로운 URI로 이동하였다. <br>이동할 곳의 새로운 URI는 응답 헤더 Location에 기록합니다. (재요청 메서드 변경되지 않음)|

- 301(Moved Permanently), 308(Permanent Redirect)의 차이점은 '클라이언트의 재요청 메서드 변경 여부'에 있음.
  + 영구적인 리다이렉션 : 자원의 위치가 영구적으로 변경되었음. 만약 어떤 URL에 요청을 보낸 결과로 영구적인 리다이렉션 관련 상태 코드를 응답받았다면, 요청을 보낸 URL은 기억할 필요가 없다고 봐도 무방함. (새로운 URL로 요청을 보내면 되므로)
  + 301(Moved Permanently) : 301 응답 메시지를 받았다고 했을 때, 이 경우 클라이언트가 보내는 두 번째 요청 메서드는 GET 요청으로 바뀔 수도 있음.
  + 308(Permanent Redirect) : 클라이언트가 308 응답 메시지를 받을 경우, 두 번째 요청 메서드는 변하지 않음. 즉, 첫 번째 요청에서 POST 메서드를 사용했다면, 상태 코드 308을 받은 뒤 보내는 두 번째 요청에서도 POST 메서드를 유지하게 됨.
- 307(Temporary Redirect) : 자원의 위치가 임시로 변경되었거나 임시로 사용할 URL이 필요한 경우에 주로 사용됨
  + 따라서 어떤 URL에 대해 일시적인 리다이렉션 관련 상태 코드를 응답받았다면 여전히 보낸 URL은 기억해야 함.

- 302(Found)는 301(Moved Permanetly)과 유사함.
  + 301 : 요청한 자원이 완전히 다른 곳으로 이동했음
    * GET이 아닌 요청 메서드를 사용한 클라이언트가 상태 코드 301을 응답받을 경우, 두 번째 요청 메서드는 GET으로 바뀔 수도 있음
  + 302 : 요청한 자원이 임시로 다른 곳으로 이동했음.
    * GET이 아닌 요청 메서드를 사용한 클라이언트가 상태 코드 302를 응답받을 경우, 두 번째 요청 메서드는 GET으로 바뀔 수도 있음
- 307(Temporary Redirect) : 두 번째 요청 메서드를 변경하지 않고, 리다이렉션함.
  + 예를 들어 POST 요청을 보낸 클라이언트가 307을 응답받을 경우, 두 번째 요청 메서드도 POST로 유지됨
- 303(see Other) : 두 번째 요청 메서드를 GET으로 바꿔 주기 위해 사용됨

### 400번대: 클라이언트 에러 상태 코드
- 클라이언트에 의한 에러가 있음을 알려주는 상태 코드.
  + 서버가 처리할 수 없는 형태로 요청을 보냈거나, 존재하지 않는 자원에 대해 요청을 보내는 경우

|상태 코드|상태 텍스트|한국어 뜻|서버 측면에서의 의미|
|---|---|---|---|
|4XX|Client Error|클라이언트 에러|클라이언트의 요청에 오류가 있다.|
|400|Bad Request|잘못된 요청|요청의 구문이 잘못되었다.<br>클라이언트가 모르는 4xx 계열 응답 코드가 반환된 경우에도 클라이언트는 400과 동일하게 처리하도록 규정하고 있습니다.|
|401|Unauthorized|인증이 없음|지정한 리소스에 대한 액세스 권한이 없다. <br>응답 헤더 WWW-Authenticate에 필요한 인증 방식을 지정합니다.|
|403|Forbidden|권한이 금지됨|지정한 리소스에 대한 액세스가 금지되었다. <br>401 인증 처리 이외의 사유로 리소스에 대한 액세스가 금지되었음을 의미합니다. 리소스의 존재 자체를 은폐하고 싶은 경우는 404 응답 코드를 사용할 수 있습니다.|
|404|Not Found|찾을 수 없음	지정한 리소스를 찾을 수 없다.|
|405|Method Not Allowed|허용되지 않은 메소드|요청한 URI가 지정한 메소드를 지원하지 않는다. <br>응답 헤더 Allow에 이 URI가 지원하는 메소드 목록을 기록합니다.|

- 인증(Authenication) 여부 : 자신이 누구인지 증명하는 것
- 권한 부여(Authorization) 여부(인가) : 인증된 주체에게 작업을 허용하는 것 

### 500번대: 서버 에러 상태 코드
|상태 코드|상태 텍스트|한국어 뜻|서버 측면에서의 의미|
|---|---|---|---|
|5XX|Server Error|서버 에러|클라이언트의 요청은 유효한데 서버가 처리에 실패하였다.|
|500|Internal Server Error|내부 서버 오류|서버에 에러가 발생하였다. <br>클라이언트가 모르는 5xx 계열의 응답 코드가 반환된 경우에도 클라이언트는 500과 동일하게 처리하도록 규정하고 있습니다.|
|501|Not Implemented|구현되지 않음	요청한 URI의 메소드에 대해 서버가 구현하고 있지 않다.|
|502|Bad Gateway|불량 게이트웨이|게이트웨이 또는 프록시 역할을 하는 서버가 그 뒷단의 서버로부터 잘못된 응답을 받았다.|
|503|Service Unavailable|서비스 제공불가|현재 서버에서 서비스를 제공할 수 없다. <br>보통은 서버의 과부하나 서비스 점검 등 일시적인 상태입니다.|

- 클라이언트와 서버는 일반적으로 일대일로 연결되어 통신하지 않음
  + 클라이언트 - 서버 사이에 게이트웨이를 비롯한 여러 중간 서버가 존재할 수 있음.
  + 이때, 클라이언트와 서버 사이에 위치한 중간 서버가 다음 그림처럼 유효하지 않거나 잘못된 응답을 받을 수도 있음. 이럴 때 502를 응답함.
 
## HTTP의 발전
- HTTP/2.0는 HTTP/1.1까지 고질적인 문제였던 HOL 블로킹(Head-Of-Line blocking)이라는 문제를 완화한 버전이기도 함.
  + HOL 블로킹이란 같은 큐에 대기하며 순차적으로 처리되는 여러 패킷이 있을 때, 첫 번째 패킷의 처리 지연으로 인해 나머지 패킷들의 처리도 모두 지연되는 문제 상황을 의미함
  + HTTP/2.0는 멀티플렉싱(multiplexing) 기법을 도입해 완화함.
      * 멀티플렉싱이란 여러 스트림을 이용해 병렬적으로 메시지를 주고받는 기술을 의미함
      * 요청과 응답을 주고받는 단위는 하나의 스트림에서 이루어지고, 이러한 스트림을 여러 개 활용하는 동시에 스트림별로 독립적인 송수신이 가능하며, 스트림별 메시지들은 꼭 일정한 순서를 유지할 필요가 없음.
      * 별도의 스트림을 통해 여러 데이터를 병렬적으로 주고받는다면 HOL 블로킹을 상당 부분 완화할 수 있음.
- HTTP/3.0은 이전까지의 HTTP 버전과는 달리 UDP 기반으로 동작함.
  + 정확히 말하면, UDP를 기반으로 구현된 QUIC(Quick UDP Internet Connections) 프로토콜을 기반으로 동작함.
  + UDP 기반이므로 속도 측면에서 큰 개선이 이루어짐.

# 05-3. HTTP 헤더와 HTTP 기반 기술
- 필드 라인 : 같은 형식을 따르는 다양한 HTTP 헤더들이 명시됨.

## 요청 시 활용되는 HTTP 헤더
### Host
- Host : 요청을 보낼 호스트를 나타내는 헤더 (주로 도메인 네임+포트 번호)

### User-Agent
- User-Agent : 웹 브라우저 같이 HTTP 요청을 시작하는 클라이언트 측의 프로그램을 의미
  + 요청 메시지 생성에 관여한 클라이언트 프로그램과 관련된 다양한 정보가 명시됨.
  + 운영체제, 브라우저 종류 및 버전, 렌더링 엔진과 같은 정보가 포함되어 있음

### Referer
- 클라이언트가 요청을 보낼 때 머무르고 있던 URL이 명시됨 (클라이언트의 유입 경로를 파악할 수 있음)

### Authorization
- 클라이언트의 인증 정보를 담는 헤더임.
- 다음처럼 인증 타입과 인증을 위한 정보가 차례로 명시됨.
  + 인증 타입에 따라 인증 정보에 명시될 값이 달라짐
- 인증 타입의 종류는 다양하지만, 가장 기본적인 HTTP 인증 타입은 Basic이라는 타입임.
  + username:password와 같이 사용자 아이디와 비밀번호를 콜론을 이용해 합친 뒤, 이를 Base64 인코딩한 값을 인증 정보로 삼는 방식임
  + Base64 인코딩 : 문자를 코드로 변환하는 방법을 의미하는 인코딩 방식의 일종

## 응답 시 활용되는 HTTP 헤더
### Server
- 요청을 처리하는 서버 측의 소프트웨어와 관련된 정보를 명시함

### Allow
- 클라이언트에게 허용된 HTTP 메서드 목록을 알려 주기 위해 사용됨
- 상태 코드 405(Method Not Allowed)를 응답하는 메시지에서 Allow 헤더가 함께 사용됨

### Retry-After
- 자원을 사용할 수 있는 날짜 혹은 시각을 나타냄.
- 상태 코드 503(Service Unavailable)는 현재는 요청을 처리할 수 없으나 추후 가능할 수도 있음을 의미하는데, 이때 함께 사용됨.

### Location
- 클라이언트에게 자원의 위치를 알려 주기 위해 사용되는 헤더
- 주로 리다이렉션이 발생했을 때나 새로운 자원이 생성되었을 때 사용됨

### WWW-Authenicate
- 자원에 접근하기 위한 인증 방식을 설명하는 헤더 (ex. Basic 인증을 요구할 수 있음)
- 보안영역(realm)을 함께 알려 주거나 인증에 사용될 문자집합(charset)도 알려 줄 수 있음
- 상태 코드 401(Unauthorized)는 요청한 자원에 대한 유효한 인증이 없을 때 응답하므로, 함께 사용할 수 있음.

## HTTP 인증을 수행하는 과정
![image](https://github.com/user-attachments/assets/11d9a618-ffa5-4add-8290-b7700cba0856)
- Authorization과 WWW-Authenicate 헤더를 통해 인증되지 않은 클라이언트가 HTTP 인증(Basic 인증)을 수행하는 과정을 그림과 함께 살펴봅시다.
1. 인증되지 않은 클라이언트가 서버에 GET 요청 메시지를 전송함
2. 서버는 클라이언트에게 상태 코드 401(Unauthorized)과 함께 WWW-Authenicate 헤더를 통해 인증 방식을 알림
3. 클라이언트는 사용자로부터 인증 정보(사용자 아이디와 비밀번호)를 전달받음
4. "사용자 아이디:비밀번호"를 Base64 인코딩한 값을 인증 정보로 삼은 Authorization 헤더를 통해 다시 GET 요청 메시지를 전송함
5. 서버는 인증 정보를 확인함
6. 인증이 유효하면 상태 코드 200으로 응답하고, 인증되지 않았으면 상태 코드 401로 응답함.

## 요청과 응답 모두에서 활용되는 HTTP 헤더
### Date
- 메시지가 생성된 날짜와 시각에 관련된 정보를 담은 헤더 (클라이언트와 서버 모두에서 사용될 수 있는 헤더)

### Connectcion
- 클라이언트의 요청과 응답 간의 연결 방식을 설정하는 헤더
- 지속 연결(keep-alive)을 명시하거나 연결을 종료하고 싶음(close)을 알릴 수 있음

### Content-Length
- 본문의 바이트 단위 크기(길이)를 나타냄

### Content-Type, Content-Language, Content-Encoding
- 메시지 본문의 표현 방식을 설명하는 헤더임
  + 어떤 점에서 이 헤더들은 표현 헤더의 일종이라고도 부름.
- content-type : 본문에서 사용된 미디어 타입을 담고 있음
- content-language : 메시지 본문에 사용된 자연어를 명시함
- content-Encoding : 메시지 본문을 압축하건 변환한 방식이 명시됨


## 캐시(cache)
- 불필요한 대역폭 낭비와 응답 지연을 방지하기 위해 정보의 사본을 임시로 저장하는 기술임
- 정보의 사본을 임시로 저장하는 것 : '캐시한다', '캐싱한다'
  + 동일한 요청에 대해 캐시된 데이터를 활용할 수 있음 -> 불필요한 대역폭 낭비 줄이기 가능 & 더 빠르게 데이터 접근

### 캐시 신선도
- 캐시 신선도 : 사본 데이터를 저장하기 때문에, 원본에 대한 최신 상태와 얼마나 유사한지를 뜻함
- 캐시 데이터에 유효 기간을 설정하고, 기간이 만료되었다면 원본 데이터를 다시 요청하는 방식으로 캐시 신선도를 유지함.
  + 응답메시지의 Expires 헤더(날짜)와 Cache-Control 헤더의 Max-Age 값(초)를 사용
- 캐시 데이터를 사용하다가, 캐시 유효 기간이 만료되었다면
  + 서버에 자원을 다시 요청.
  + 1) 만약 원본 데이터가 변하지않았다면, 캐시된 자원을 유효 기간을 연장하여 이용하면 됨
  + 2) 원본 데이터가 변하였다면,   

## 쿠키


## 콘텐츠 협상과 표현


  


# 03-1 LAN을 넘어서는 네트워크 계층

- 앞서 학습한 범위는 일반적으로 LAN에 한정됨
  + LAN을 넘어서 다른 네트워크와 통신하기 위해서는 `네트워크 계층`이 필수적임
  + 이는 IP 주소를 이용해 송수신지 대상을 지정하고,
  + 라우팅으로 다른 네트워크에 이르는 경로를 결정함
 
## 데이터 링크 계층의 한계

- 물리 계층, 데이터 링크 계층만으로 왜 다른 지역에 있는 사람과 통신이 되지 않을까?

### 다른 네트워크까지의 도달 경로를 파악하기 어려움

- 라우팅 routing : 패킷이 이동할 최적의 경로를 결정해 줌.
  + 물리 계층, 데이터 링크 계층의 장비로는 라우팅을 수행할 수 없음 → 네트워크 계층의 장비(라우터)로는 가능함.
 
### MAC 주소만으로는 모든 네트워크에 속한 호스트의 위치를 특정하기 어려움

- 현실적으로 모든 MAC 주소가 어디있는지 특정하기 어려움.
- 택배를 예시로 들자면,
  + 수신인 정보 : MAC 주소(물리 주소)
  + 수신지 정보 : IP 주소(논리 주소) → 배달할 땐 도착지 정보를 우선으로 봄! 따라서 IP 주소를 우선으로 활용
    * DHCP(Dynamic Host Configuration Protocol) : IP 주소를 자동으로 할당받는 프로토콜. / 사용자가 직접 할당할 수도 있고, 복수의 IP 주소를 가질 수도 있음

## 인터넷 프로토콜(IP)

### IP 주소 형태
![image](https://github.com/user-attachments/assets/3239a5df-d4ce-4363-b03e-655d62d64536)

- IP(IPv4) : 4바이트(32비트)로 주소를 표현 가능함. 1/1/1/1바이트로 나눠 표현 → 0~255 범위 안에 있는 네 개의 10진수로 표기됨 (옥텟octet)
  + 데이터 링크 계층의 프레임의 페이로드 = IP 패킷

![image](https://github.com/user-attachments/assets/4ef654f4-0d9b-4599-bde2-f79fd7828e96)

- 식별자, 플래그, 단편화 오프셋으로 단편화와 재조합을 할 수 있다!
- 프로토콜 필드로 상위 계층 프로토콜을 알 수 있고
- TTL로는 패킷의 남은 수명, 송신지IP, 수신지IP 주소로 IP 주소를 지정할 수 있음!

1. 식별자 (identifier)
  + IP 단편화 기능에 관여
  + 패킷에 할당된 번호. 여러 조각으로 쪼개진 패킷들을 다시 재조합하기 위해 식별자를 사용
2. 플래그 (flag)
  + IP 단편화 기능에 관여
  + 세 개의 비트로 구성되어 있음
  + 첫 번째 비트 : 0으로 예약된 비트
  + 두 번째 비트 DF (Don't Fragment) : IP 단편화를 수행하지 말라는 표시. 1(수행 불가), 0(수행 가능)
  + 세 번째 비트 MF (More Fragment) : 단편화된 패킷이 더 있는지를 나타냄. 0(마지막 패킷), 1(쪼개진 패킷이 더 있음)
3. 단편화 오프셋 (fragment offset)
  + IP 단편화 기능에 관여
  + 패킷이 단편화되기 전에 패킷의 초기 데이터에서 몇 번째로 떨어진 패킷인지를 나타냄. (단편화된 패킷이 수신지에 순서대로 도착하지 않을 수 있기 때문에)
  + 따라서 이를 통해 몇 번째에 해당하는 패킷인지 알고, 재조합할 수 있음.
4. TTL (Time To Live)
  + 패킷의 수명을 의미 ; ICMP 프로토콜과 관련
  + 패킷이 하나의 라우터를 거칠 때마다 TTL이 1씩 감소하여, 0으로 떨어지면 폐기됨 → 무의미한 패킷이 네트워크상에 지속적으로 남아있는 것을 방지
  + 홉(hop) : 호스트 또는 라우터에 한 번 전달되는 것
  
5. 프로토콜
  + 상위 계층 프로토콜이 무엇인지 나타내는 필드 (TCP: 6, UDP: 17)
  
6. 송신지 IP 주소 (Source IP Address)
  + IP 주소 지정 기능에 관여
7. 수신지 IP 주소 (Destination IP Address)
  + IP 주소 지정 기능에 관여



### IP 기능1 : IP 주소 지정(IP addressing)
- IP 주소를 바탕으로 송수신 대상을 지정하는 것을 의미


### IP 기능2 : IP 단편화 (IP fragmentation)
![image](https://github.com/user-attachments/assets/65915c36-3366-4419-9e8d-a4339f3d83b0)
![image](https://github.com/user-attachments/assets/722551c4-e29c-4968-ab13-a9444d3baffa)


- 전송하고자 하는 패킷의 크기가 MTU라는 최대 전송 단위보다 클 경우, MTU 크기 이하의 복수의 패킷으로 나누는 것을 의미
- MTU, Maximum Transmission Unit) : 한 번에 전송 가능한 IP 패킷(헤더+바디)의 최대 크기를 말함
  + MTU 크기 이하로 나누어진 패킷은 수신지에 도착하면 다시 재조합됨

 
### IPv6
- 할당 가능한 IPv4 주소는 $2^32$개 = 약 43억 개
- IPv6는 16바이트(128비트)로, $2^128$개로 많은 수를 할당할 수 있음

![image](https://github.com/user-attachments/assets/137f135b-00e0-421a-aff0-985558c77ed5)

1. 다음 헤더 (next header)
   ![image](https://github.com/user-attachments/assets/1a6ab2f2-e90b-4057-9f35-ed8fcac2d68a)

   + 상위 계층의 프로토콜을 가리키거나 확장 헤더를 가리킴
   + 확장 헤더? : IPv6의 추가적인 헤더 정보가 필요할 때 가지는 추가 헤더 (기본 헤더와 페이로드 데이터 사이에 위치)
     * 홉 간 옵션, Hop-by-Hop Options : 모든 경로의 네트워크 장비가 패킷을 검사하도록 함
     * 수신지 옵션, Destination Options : 수신지에서만 패킷을 검사하도록 하는 수신지 옵션
     * 라우팅, Routing : 라우팅 관련 정보를 운반
     * 단편, Fragment : 단편화를 위한 단편  → 필드가 하닌 확장 헤더를 통해 단편화가 이뤄짐.
       - ![image](https://github.com/user-attachments/assets/d806c79d-3cf8-499a-967e-874c82b647a1)
       - 다음 헤더를 통해 또 다른 확장 헤더를 가리킬 수 있음
       - 단편화 오프셋 : M플래그(현재 단편화된 패킷의 위치. 0이면 마지막 패킷), 식별자(동일한 메시지에서부터 단편화된 패킷임) 필드로 IPv4와 같은 역할을 함.

     * ESP, Enscapsulating Security Payload / AH, Authenication Header : 암호화와 인증을 위함
3. 홉 제한 (hop limit)
   + IPv4 패킷의 TTL 필드와 비슷하게 패킷의 수명을 나타내는 필드
5. 송신지 IP 주소
6. 수신지 IP 주소
   + IPv4 패킷의 헤더 길이는 가변적임 (옵션, 패딩 필드가 선택적으로 존재)
   + IPv6 기본 헤더는 40바이트로 고정적


## ARP, Address Resolution Protocol
- 기본적으로는 IP 주소를 확인함. 따라서 상대 호스트의 IP 주소는 알지만 MAC 주소는 알지못할 수도... 이를 위한 프로토콜
- 동일 네트워크 내에 있는 송수신 대상의 IP 주소를 통해 MAC 주소를 알아낼 수 있음
- 동작 과정
  1. ARP 요청
  2. ARP 응답
  3. ARP 테이블 갱신
  + 상황) A는 B에게 패킷을 보내려고 함. 근데 B의 IP주소는 있지만 MAC주소는 알지못함

### 1. ARP 요청, ARP Request
- MAC주소를 알고 싶어하는 A는 네트워크 내 모든 호스트에게 브로드캐스트 메시지를 보냄
- "IP주소가 123인 사람 MAC주소 내놔"

### 2. ARP 응답, ARP Reply
- ARP 요청 메시지를 받고 해당한다면 MAC 주소를 담은 메시지를 전송하는 것
- "어 난데 MAC주소 456이다"
- ARP 요청, 응답 과정에서는 ARP 패킷이 사용됨
  + ![image](https://github.com/user-attachments/assets/0c4de675-3b6c-405d-b3e5-e7c771a04a03)
  + 오퍼레이션 코드 (Opcode; Operation Code) : ARP 패킷의 유형을 나타냄. ARP 요청(1), ARP 응답(2)
  + 송신지 하드웨어 주소/수신지 하드웨어 주소 : MAC 주소가 명시됨.
    * ARP 요청 시 이더넷 프레임 '수신지 MAC 주소 : ff:ff:ff:ff:ff:ff (브로드캐스트 메시지임을 명시)'
    * ARP 패킷 '수신지 하드웨어 주소 : 00:00:00:00:00:00'
  + 송신지 프로토콜 주소/수신지 프로토콜 주소 : IP 주소가 명시됨


### 3. ARP 테이블 갱신, ARP Table
- ARP 테이블 : IP 주소와 그에 맞는 MAC 주소 테이블을 대응하는 표
  + ARP 요청, 응답을 통해 MAC 주소를 알게 되면 ARP 테이블에 IP주소와 MAC주소를 추가함. ➡ 다음부터 브로드캐스트 할 필요 없음
- ARP 테이블은 일정 시간이 지나면 삭제되고, 임의로 삭제할 수도 있음

### 다른 네트워크에 속해있는 호스트 알아내기
- 예시
  + 호스트 A는 호스트 B와 동일한 네트워크에 있지 않음.
  + 호스트 A는 라우터 A의 MAC 주소를 모른다면 ARP 요청 - ARP 응답 과정을 통해 패킷을 전송해서 알아옴
  + 호스트 A에서 패킷을 전달받은 라우터 A는 패킷을 라우터 B로 전달해야 함.
  + 만일 라우터 A가 라우터 B의 MAC 주소를 모른다면 한 번 더 ARP 요청 - ARP 응답 과정을 거쳐 알아옴
  + 라우터 B는 호스트 B에게 패킷을 전달해야 함.
  + 만일 라우터 B가 호스트 B의 MACC 주소를 모르면 똑같이 ARP 요청 - 응답 과정을 거쳐 알아옴
- 현실에서는 라우터 간 통신을 주고받을 때 ARP만 사용하진 않음. (다양한 고려 사항 있음)

## IP 단편화를 피하는 방법
- IP 단편화는 되도록 하지 않는 것이 좋은데, 데이터가 여러 패킷으로 쪼개지면 자연스레 전송해야 할 패킷의 헤더들도 많아지기 때문.
  + 불필요한 트래픽 증가와 대역폭 낭비로 이어질 수 있기 때문
- 그렇다면 피하는 방법?
  + 호스트/라우터의 처리 가능한 MTU 크기를 고려해야 함
  + IP 단편화 없이 주고 받을 수 있는 최대 크기만큼만 전송해야 함. 이 크기를 경로 MTU. 이를 찾는 기술을 '경로 MTU 발견, Path MTU discovery'라고 함.
- 오늘 날 네트워크에서는 경로 MTU 발견을 지원하고, 처리 가능한 MTU 크기도 대부분 균일하기 때문에 IP 단편화는 자주 수행되지 않음.
- 만약 DF 플래그가 활성화되어 있지만, 단편화 없이 처리 불가능한 크기의 패킷이라면 전달받은 패킷에 대한 메시지로 "단편화 없이 처리할 수 없다"는 오류를 전달함. 따라서 이 메시지를 안 받기까지 계속 데이터 크기를 줄이게 되어 경로 MTU를 알아감. 







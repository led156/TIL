# 03-1 LAN을 넘어서는 네트워크 계층

- 앞서 학습한 범위는 일반적으로 LAN에 한정됨
  + LAN을 넘어서 다른 네트워크와 통신하기 위해서는 `네트워크 계층`이 필수적임
  + 이는 IP 주소를 이용해 송수신지 대상을 지정하고,
  + 라우팅으로 다른 네트워크에 이르는 경로를 결정함
 
## 데이터 링크 계층의 한계

- 물리 계층, 데이터 링크 계층만으로 왜 다른 지역에 있는 사람과 통신이 되지 않을까?

### 다른 네트워크까지의 도달 경로를 파악하기 어려움

- 라우팅 routing : 패킷이 이동할 최적의 경로를 결정해 줌.
  + 물리 계층, 데이터 링크 계층의 장비로는 라우팅을 수행할 수 없음 → 네트워크 계층의 장비(라우터)로는 가능함.
 
### MAC 주소만으로는 모든 네트워크에 속한 호스트의 위치를 특정하기 어려움

- 현실적으로 모든 MAC 주소가 어디있는지 특정하기 어려움.
- 택배를 예시로 들자면,
  + 수신인 정보 : MAC 주소(물리 주소)
  + 수신지 정보 : IP 주소(논리 주소) → 배달할 땐 도착지 정보를 우선으로 봄! 따라서 IP 주소를 우선으로 활용
    * DHCP(Dynamic Host Configuration Protocol) : IP 주소를 자동으로 할당받는 프로토콜. / 사용자가 직접 할당할 수도 있고, 복수의 IP 주소를 가질 수도 있음

## 인터넷 프로토콜(IP)

### IP 주소 형태
![image](https://github.com/user-attachments/assets/3239a5df-d4ce-4363-b03e-655d62d64536)

- IP(IPv4) : 4바이트(32비트)로 주소를 표현 가능함. 1/1/1/1바이트로 나눠 표현 → 0~255 범위 안에 있는 네 개의 10진수로 표기됨 (옥텟octet)
  + 데이터 링크 계층의 프레임의 페이로드 = IP 패킷

![image](https://github.com/user-attachments/assets/4ef654f4-0d9b-4599-bde2-f79fd7828e96)

- 식별자, 플래그, 단편화 오프셋으로 단편화와 재조합을 할 수 있다!
- 프로토콜 필드로 상위 계층 프로토콜을 알 수 있고
- TTL로는 패킷의 남은 수명, 송신지IP, 수신지IP 주소로 IP 주소를 지정할 수 있음!

1. 식별자 (identifier)
  + IP 단편화 기능에 관여
  + 패킷에 할당된 번호. 여러 조각으로 쪼개진 패킷들을 다시 재조합하기 위해 식별자를 사용
2. 플래그 (flag)
  + IP 단편화 기능에 관여
  + 세 개의 비트로 구성되어 있음
  + 첫 번째 비트 : 0으로 예약된 비트
  + 두 번째 비트 DF (Don't Fragment) : IP 단편화를 수행하지 말라는 표시. 1(수행 불가), 0(수행 가능)
  + 세 번째 비트 MF (More Fragment) : 단편화된 패킷이 더 있는지를 나타냄. 0(마지막 패킷), 1(쪼개진 패킷이 더 있음)
3. 단편화 오프셋 (fragment offset)
  + IP 단편화 기능에 관여
  + 패킷이 단편화되기 전에 패킷의 초기 데이터에서 몇 번째로 떨어진 패킷인지를 나타냄. (단편화된 패킷이 수신지에 순서대로 도착하지 않을 수 있기 때문에)
  + 따라서 이를 통해 몇 번째에 해당하는 패킷인지 알고, 재조합할 수 있음.
4. TTL (Time To Live)
  + 패킷의 수명을 의미 ; ICMP 프로토콜과 관련
  + 패킷이 하나의 라우터를 거칠 때마다 TTL이 1씩 감소하여, 0으로 떨어지면 폐기됨 → 무의미한 패킷이 네트워크상에 지속적으로 남아있는 것을 방지
  + 홉(hop) : 호스트 또는 라우터에 한 번 전달되는 것
  
5. 프로토콜
  + 상위 계층 프로토콜이 무엇인지 나타내는 필드 (TCP: 6, UDP: 17)
  
6. 송신지 IP 주소 (Source IP Address)
  + IP 주소 지정 기능에 관여
7. 수신지 IP 주소 (Destination IP Address)
  + IP 주소 지정 기능에 관여



### IP 기능1 : IP 주소 지정(IP addressing)
- IP 주소를 바탕으로 송수신 대상을 지정하는 것을 의미


### IP 기능2 : IP 단편화 (IP fragmentation)
![image](https://github.com/user-attachments/assets/65915c36-3366-4419-9e8d-a4339f3d83b0)
![image](https://github.com/user-attachments/assets/722551c4-e29c-4968-ab13-a9444d3baffa)


- 전송하고자 하는 패킷의 크기가 MTU라는 최대 전송 단위보다 클 경우, MTU 크기 이하의 복수의 패킷으로 나누는 것을 의미
- MTU, Maximum Transmission Unit) : 한 번에 전송 가능한 IP 패킷(헤더+바디)의 최대 크기를 말함
  + MTU 크기 이하로 나누어진 패킷은 수신지에 도착하면 다시 재조합됨

 
### IPv6
- 할당 가능한 IPv4 주소는 $2^32$개 = 약 43억 개
- IPv6는 16바이트(128비트)로, $2^128$개로 많은 수를 할당할 수 있음

![image](https://github.com/user-attachments/assets/137f135b-00e0-421a-aff0-985558c77ed5)

1. 다음 헤더 (next header)
   ![image](https://github.com/user-attachments/assets/1a6ab2f2-e90b-4057-9f35-ed8fcac2d68a)

   + 상위 계층의 프로토콜을 가리키거나 확장 헤더를 가리킴
   + 확장 헤더? : IPv6의 추가적인 헤더 정보가 필요할 때 가지는 추가 헤더 (기본 헤더와 페이로드 데이터 사이에 위치)
     * 홉 간 옵션, Hop-by-Hop Options : 모든 경로의 네트워크 장비가 패킷을 검사하도록 함
     * 수신지 옵션, Destination Options : 수신지에서만 패킷을 검사하도록 하는 수신지 옵션
     * 라우팅, Routing : 라우팅 관련 정보를 운반
     * 단편, Fragment : 단편화를 위한 단편  → 필드가 하닌 확장 헤더를 통해 단편화가 이뤄짐.
       - ![image](https://github.com/user-attachments/assets/d806c79d-3cf8-499a-967e-874c82b647a1)
       - 다음 헤더를 통해 또 다른 확장 헤더를 가리킬 수 있음
       - 단편화 오프셋 : M플래그(현재 단편화된 패킷의 위치. 0이면 마지막 패킷), 식별자(동일한 메시지에서부터 단편화된 패킷임) 필드로 IPv4와 같은 역할을 함.

     * ESP, Enscapsulating Security Payload / AH, Authenication Header : 암호화와 인증을 위함
3. 홉 제한 (hop limit)
   + IPv4 패킷의 TTL 필드와 비슷하게 패킷의 수명을 나타내는 필드
5. 송신지 IP 주소
6. 수신지 IP 주소
   + IPv4 패킷의 헤더 길이는 가변적임 (옵션, 패딩 필드가 선택적으로 존재)
   + IPv6 기본 헤더는 40바이트로 고정적


## ARP, Address Resolution Protocol
- 기본적으로는 IP 주소를 확인함. 따라서 상대 호스트의 IP 주소는 알지만 MAC 주소는 알지못할 수도... 이를 위한 프로토콜
- 동일 네트워크 내에 있는 송수신 대상의 IP 주소를 통해 MAC 주소를 알아낼 수 있음
- 동작 과정
  1. ARP 요청
  2. ARP 응답
  3. ARP 테이블 갱신
  + 상황) A는 B에게 패킷을 보내려고 함. 근데 B의 IP주소는 있지만 MAC주소는 알지못함

### 1. ARP 요청, ARP Request
- MAC주소를 알고 싶어하는 A는 네트워크 내 모든 호스트에게 브로드캐스트 메시지를 보냄
- "IP주소가 123인 사람 MAC주소 내놔"

### 2. ARP 응답, ARP Reply
- ARP 요청 메시지를 받고 해당한다면 MAC 주소를 담은 메시지를 전송하는 것
- "어 난데 MAC주소 456이다"
- ARP 요청, 응답 과정에서는 ARP 패킷이 사용됨
  + ![image](https://github.com/user-attachments/assets/0c4de675-3b6c-405d-b3e5-e7c771a04a03)
  + 오퍼레이션 코드 (Opcode; Operation Code) : ARP 패킷의 유형을 나타냄. ARP 요청(1), ARP 응답(2)
  + 송신지 하드웨어 주소/수신지 하드웨어 주소 : MAC 주소가 명시됨.
    * ARP 요청 시 이더넷 프레임 '수신지 MAC 주소 : ff:ff:ff:ff:ff:ff (브로드캐스트 메시지임을 명시)'
    * ARP 패킷 '수신지 하드웨어 주소 : 00:00:00:00:00:00'
  + 송신지 프로토콜 주소/수신지 프로토콜 주소 : IP 주소가 명시됨


### 3. ARP 테이블 갱신, ARP Table
- ARP 테이블 : IP 주소와 그에 맞는 MAC 주소 테이블을 대응하는 표
  + ARP 요청, 응답을 통해 MAC 주소를 알게 되면 ARP 테이블에 IP주소와 MAC주소를 추가함. ➡ 다음부터 브로드캐스트 할 필요 없음
- ARP 테이블은 일정 시간이 지나면 삭제되고, 임의로 삭제할 수도 있음

### 다른 네트워크에 속해있는 호스트 알아내기
- 예시
  + 호스트 A는 호스트 B와 동일한 네트워크에 있지 않음.
  + 호스트 A는 라우터 A의 MAC 주소를 모른다면 ARP 요청 - ARP 응답 과정을 통해 패킷을 전송해서 알아옴
  + 호스트 A에서 패킷을 전달받은 라우터 A는 패킷을 라우터 B로 전달해야 함.
  + 만일 라우터 A가 라우터 B의 MAC 주소를 모른다면 한 번 더 ARP 요청 - ARP 응답 과정을 거쳐 알아옴
  + 라우터 B는 호스트 B에게 패킷을 전달해야 함.
  + 만일 라우터 B가 호스트 B의 MACC 주소를 모르면 똑같이 ARP 요청 - 응답 과정을 거쳐 알아옴
- 현실에서는 라우터 간 통신을 주고받을 때 ARP만 사용하진 않음. (다양한 고려 사항 있음)

## IP 단편화를 피하는 방법
- IP 단편화는 되도록 하지 않는 것이 좋은데, 데이터가 여러 패킷으로 쪼개지면 자연스레 전송해야 할 패킷의 헤더들도 많아지기 때문.
  + 불필요한 트래픽 증가와 대역폭 낭비로 이어질 수 있기 때문
- 그렇다면 피하는 방법?
  + 호스트/라우터의 처리 가능한 MTU 크기를 고려해야 함
  + IP 단편화 없이 주고 받을 수 있는 최대 크기만큼만 전송해야 함. 이 크기를 경로 MTU. 이를 찾는 기술을 '경로 MTU 발견, Path MTU discovery'라고 함.
- 오늘 날 네트워크에서는 경로 MTU 발견을 지원하고, 처리 가능한 MTU 크기도 대부분 균일하기 때문에 IP 단편화는 자주 수행되지 않음.
- 만약 DF 플래그가 활성화되어 있지만, 단편화 없이 처리 불가능한 크기의 패킷이라면 전달받은 패킷에 대한 메시지로 "단편화 없이 처리할 수 없다"는 오류를 전달함. 따라서 이 메시지를 안 받기까지 계속 데이터 크기를 줄이게 되어 경로 MTU를 알아감. 


# 03-2 IP 주소
- IP 주소 :
  + 네트워크 주소 / 네트워크 ID / 네트워크 식별자 : 호스트가 속한 특정 네트워크를 식별하는 역할
  + 호스트 주소 / 호스트 ID / 호스트 식별자 : 네트워크 내에서 특정 호스트를 식별하는 역할
- 네트워크 주소가 3옥텟 : 호스트 주소가 1옥텟... 처럼 구분하는 범위는 유동적일 수 있음
  + 주소를 잘 할당할 수 있도록 클래스class 도입

## 클래스풀 주소 체계, classfull addressing
- 클래스 : 네트워크 크기에 따라 IP주소를 분류하는 기준.
  + A클래스 : 네트워크 주소 1옥텟(0~127) / 호스트 주소 3옥텟
  + B클래스 : 네트워크 주소 2옥텟(128~191) / 호스트 주소 2옥텟
  + C클래스 : 네트워크 주소 3옥텟(192~223) / 호스트 주소 1옥텟
- 호스트 주소 공간
  + 호스트 주소가 전부 0인 IP주소, 호스트 주소가 전부 1인 IP주소는 특정 호스트를 지칭하는 IP 주소로 활용할 수 없음.
  + 전부 0 : 해당 네트워크 자체를 의미, 전부 1 : 브로드캐스트를 위한 주소로 사용

|클래스|초기 비트|네트워크 주소 비트/호스트 주소 비트|할당 가능한 네트워크 수|할당 가능한 호스트 수|
|-----|--------|----------------------------------|-----------------|-----------------|
|A|0|8/24|$2^7(128)$|$2^24-2$|
|B|10|16/16|$2^14(16,384)$|$2^16-2$|
|C|110|24/8|$2^21(2,097,152)$|$2^8-2$|

## 클래스리스 주소 체계, classless addressing
- 다만 클래스풀 주소 체계를 이용해도 클래스별 네트워크 크기가 고정되어 있기 때문에 여전히 다수 IP주소가 낭비될 가능성이 있음
- 따라서 클래스리스 주소 체계는 유동적이고 정교하게 네트워크를 구획할 수 있는 방법임

### 서브넷 마스크, subnet mask
- 네트워크와 호스트를 구분 짓는 수단
- 네트워크 주소는 1, 호스트 주소는 0으로 표기한 비트열
- 서브네팅 subnetting : 서브넷 마스크를 이용해 클래스를 원하는 크기로 더 잘게 쪼개어 사용하는 것
- 예시) A 클래스: 255.0.0.0 (11111111.00000000.00000000.00000000)


- 서브네팅 : 비트 AND 연산
  + IP 주소와 서브넷 마스크를 비트 AND 연산하면 네트워크/호스트 주소를 구분지을 수 있음!
  + AND 연산 후 나온 결과는 네트워크 주소가 됨.

- 서브넷 마스크 표기 : CIDR 표기법
  1. 서브넷 마스크를 10진수로 표기하는 방법
  2. CIDR 표기법 : IP주소/서브넷 마스크상의 1의 개수 형식으로 표기하는 방법
  + 예시) IP 주소 192.168.219.103과 서브넷 마스크 255.255.255.0 ➡ 192.168.219.103/24

## 공인 IP 주소와 사설 IP 주소
- 공인 IP 주소 (public)
  + 네트워크 간의 통신에 사용하는 IP 주소
  + ISP나 공인 IP ㅈ소 할당 기관을 통해 할당받을 수 있음

- 사설 IP 주소와 NAT (private)
  + 사설 네트워크에서 사용하기 위한 IP 주소
  + 예약된 IP 주소 공간이 있음
    * 10.0.0.0/8 (10.0.0.0 - 10.255.255.255)
    * 172.16.0.0/12 (172.16.0.0 - 172.31.255.255)
    * 192.168.0.0/16 (192.168.0.0 - 192.168.255.255)
  + 라우터가 할당해줌.
  + 사설 IP 주소를 갖는 호스트가 외부 네트워크와 통신하려면 NAT 기술을 사용함.

### NAT, Network Address Translation
- IP 주소를 변환함. (사설 IP ↔️ 공인 IP)
- 라우터와 가정용 공유기가 해당 기능을 내장.
1. 사설 IP 주소는 공유기를 거쳐 공인 IP로 변경되고, 외부 네트워크로 전송됨.
2. 외부 네트워크로부터 받은 패킷 속 공인 IP 주소는 공유기를 거쳐 사설 IP 주소로 변경됨

## 정적 IP 주소와 동적 IP 주소
### 정적 할당
- 호스트에 직접 수작업으로 IP 주소를 부여하는 방식

### 동적 할당과 DHCP
- 동적 IP 주소는 사용되지 않을 경우 회수되고, 할당받을 때마다 다른 주소를 받을 수 있음.
- DHCP (Dynamic Host Configuration Protocol) : 응용 계층에 속함.
  + DHCP 서버간 메시지를 주고받음으로써 P 주소가 할당됨.
  + DHCP 서버는 클라이언트에게 할당 가능한 IP 주소 목록을 관리하다가, 클라이언트가 요청할 때 IP 주소를 할당함.
- 유의할 점은 DHCP로 할당받은 IP 주소는 사용할 기간이 정해져 있다는 점.
- ![image](https://github.com/user-attachments/assets/56fa395e-d901-4165-bfbe-581166aed674)
1. DHCP Discover(클라이언트 ➡ DHCP 서버)
   + 클라이언트는 해당 메시지를 통해 DHCP 서버를 찾음. (브로드캐스트로 전송)
   + 아직 IP 주소를 할당받지 못했으므로 송신지 IP 주소는 0.0.0.0으로 설정됨
2. DHCP Offer(DHCP 서버 ➡ 클라이언트)
   + 서버는 DHCP Discover 메시지를 받은 뒤 클라이언트에게 해당 메시지를 보냄
   + 제안할 IP 주소, 서브넷 마스크, 임대 기간 등이 포함되어 있음
3. DHCP Request(클라이언트 ➡ DHCP 서버)
   + DHCP Offer에 대한 응답으로, 브로드캐스트로 전송됨
4. DHCP ACK(DHCP 서버 ➡ 클라이언트)
   + 마지막으로 서버가 클라이언트에게 ACK 메시지를 보냄. (최종 승인)
- 만약 IP 주소 임대 기간이 끝나기 전에 임대 기간을 연장하는 것을 '임대 갱신, lease renewal'이라고 함. 이는 두차례 자동으로 수행되는데, 만약 실패하면 그냥 반납함.

## 예약 주소
...


# 03-3 라우팅
![image](https://github.com/user-attachments/assets/bc1a1237-d371-42e7-9b14-b9260a12df03)

## 라우터 (L3 스위치)
- 여러 대의 라우터를 거쳐 패킷이 도달함.
  + 라우터 간 이동하는 하나의 과정을 홉hop이라고 함.
  + 어떻게 홉을 지정할 수 있을까?

### 라우팅 테이블, routing table
- 라우터는 라우팅 테이블을 참고하여 수신지까지의 도달 경로를 판단함.
- 라우팅 테이블에 포함된 정보
  + 수신지 IP 주소와 서브넷 마스크 : 최종적으로 패킷을 전달할 대상을 의미
  + 다음 홉 next hop / 게이트웨이 : 최종 수신지까지 가기 위해 다음으로 거쳐야 할 호스트의 IP 주소나 인터페이스를 의미.
  + 네트워크 인터페이스 : 패킷을 내보낼 통로. NIC 이름이나 IP주소가 명시됨
  + 메트릭 metric : 해당 경로로 이동하는데 드는 비용을 의미
- 디폴트 라우트 : 라우팅 테이블에 없는 경로로 패킷을 전송해야 할 때가 있기 때문에, 기본적으로 패컷을 내보낼 경로를 설정하여 해당 경로로 패킷을 내보내야 함. (모든 IP 주소를 의미하는 0.0.0.0/0으로 명시함)
  + 내부 호스트 A가 외부 호스트 B에게 패킷을 보낼 때, B에게 어떻게 보낼지 모름! 따라서 A는 우선 패킷을 라우터에게 전달하는데, 이를 위해 A는 라우터 주소인 기본 게이트웨이를 디폴트 라우트로 삼아 전달함!!! 


## 정적 라우팅과 동적 라우팅
- 라우팅 테이블을 만드는 방법
- 정적 라우팅 static routing : 사용자가 수동으로 직접 채워 넣은 라우팅 테이블
- 동적 라우팅 dynamic routing : 자동으로 라우팅 테이블 항목을 만들고, 이를 이용하여 라우팅하는 방식.
  + 대규모 네트워크를 관리하는 데 있어서 더욱 편리하고, 경로상 문제가 생겼을 때 우회도 가능함.
  + 모든 라우터는 특정 수신지까지 최적 경로를 찾아 라우팅 테이블에 추가하려 노력함.
  + 이를 위해 라우터끼리 서로 자신의 정보를 교환하기 때문에 이 과정에서 사용되는 프로토콜임.

## 라우팅 프로토콜 routing protocol
- 라우터끼리 자신들의 정보를 교환하여 패킷이 이동할 최적의 경로를 찾기 위한 프로토콜임.
- 라우팅 프로토콜이 AS 내부에서 수행되냐(IGP, Interior Gateway Protocol), AS 외부에서 수행되냐(EGP, Exterior Gateway Protocol)에 따라 종류가 나뉨
  + AS(Autonomous System) : 동일한 라우팅 정책으로 운용되는 라우터들의 집단 네트워크

### IGP: RIP와 OSPF
- RIP, Routing Information Protocol
  + 프로토콜들이 최적 경로를 선정하는 과정에서 거리 벡터를 사용함.
  + 거리를 기반으로 즉 경유한 라우터의 수 (홉의 수)를 기준으로 함
  + 인접 라우터끼리 경로 정보를 주기적으로 교환하여 라우팅 테이블을 갱신
- OSPF, Open Shortest Path First
  + 프로토콜들이 최적 경로를 선정하는 과정에서 링크 상태를 사용함.
  + 현재 네트워크 상태를 그래프의 형태로 링크 상태 데이터베이스(LSDB)에 저장함.
    * LSDB에는 라우터들의 연결 관계, 연결 비용 등 데이터가 저장됨
  + 이를 기반으로 현재 네트워크 구성을 마치 지도처럼 그린 뒤 최적의 경로를 선택함.
  + 최적의 경로를 결정하기 위해 대역폭을 기반으로 메트릭을 계산함 (대역폭이 높은 링크일수록 메트릭이 낮은 경로로 인식)
  + 네트워크 구성이 변경되었을 때 라우팅 테이블이 갱신
  + 영역이 커지면 운용이 어려우므로, AS를 에어리어라는 단위로 나누고 이 안에서만 공유함.
    * 에어리어 경계에 있는 ABR이라는 라우터가 에어리어 간의 연결을 담당함.
   
### EGP: BGP
- BGP, Border Gateway Protocol
  + AS 간 통신에서 사용되는 대표적인 프로토콜 (; AS 간의 통신이 가능한 프로토콜)
  + AS 간 통신을 위한 BGP는 eBGP, 내의 통신을 위한 BGP는 iBGP
  + AS 간 정보를 주고받기 위해 AS 내에 BGP 라우터(eBGP)가 하나 이상 있어야 하고, 또 다른 BGP 라우터와 연결되어야 함.
    * 해당 연결은 BGP 메시지를 주고받음으로써 이뤄짐. 이를 피어peer라고 정의하고, 연결되는 과정을 피어링peering이라고 함.
- BGP는 RIP와 OSPF에 비해 최적 경로를 결정하는 과정이 복잡하고, 일정하지 않은 경우가 많음
  + 경로 결정 과정에서 수신지 주소와 더불어 다양한 '속성'(AS-PATH, NEXT-HOP, LOCAL-PREF)과 '정책'이 고려되기 때문임.

